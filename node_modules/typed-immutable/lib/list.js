(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['exports', './typed', 'immutable'], factory);
  } else if (typeof exports !== 'undefined') {
    factory(exports, require('./typed'), require('immutable'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.typed, global.Immutable);
    global.list = mod.exports;
  }
})(this, function (exports, _typed, _immutable) {
  'use strict';

  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

  function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _defaults(subClass, superClass); }

  var ImmutableList = _immutable.List;
  var Indexed = _immutable.Iterable.Indexed;

  var $store = _typed.Typed.store;
  var $type = _typed.Typed.type;
  var $read = _typed.Typed.read;
  var $step = _typed.Typed.step;
  var $init = _typed.Typed.init;
  var $result = _typed.Typed.result;
  var $label = _typed.Typed.label;
  var $typeName = _typed.Typed.typeName;
  var $empty = _typed.Typed.empty;

  var change = function change(list, f) {
    var store = f(list[$store]);
    if (store === list[$store]) {
      return list;
    } else {
      var result = list.__ownerID ? list : (0, _typed.construct)(list);
      result[$store] = store;
      result.size = store.size;
      return result;
    }
  };

  var _clear = function _clear(target) {
    return target.clear();
  };
  var _pop = function _pop(target) {
    return target.pop();
  };
  var _shift = function _shift(target) {
    return target.shift();
  };

  var TypeInferer = (function (_Type) {
    function TypeInferer() {
      _classCallCheck(this, TypeInferer);

      _get(Object.getPrototypeOf(TypeInferer.prototype), 'constructor', this).apply(this, arguments);
    }

    _inherits(TypeInferer, _Type);

    _createClass(TypeInferer, [{
      key: _typed.Typed.typeName,
      value: function value() {
        return 'TypeInferer';
      }
    }, {
      key: _typed.Typed.read,
      value: function value(_value) {
        // typeOf usually creates type for the value with that
        // value being a default. For type inference we should
        // actually use a base type instead of type with default
        // there for we use prototype of the constructor.
        var type = (0, _typed.typeOf)(_value).constructor.prototype;
        this.type = this.type ? (0, _typed.Union)(this.type, type) : type;
        return _value;
      }
    }]);

    return TypeInferer;
  })(_typed.Type);

  function BaseImmutableList() {}
  BaseImmutableList.prototype = ImmutableList.prototype;

  var TypeInferedList = (function (_BaseImmutableList) {
    _inherits(TypeInferedList, _BaseImmutableList);

    _createClass(TypeInferedList, null, [{
      key: 'from',
      value: function from(list) {
        var result = (0, _typed.construct)(this.prototype);
        result[$store] = list[$store];
        result.size = list.size;
        return result;
      }
    }]);

    function TypeInferedList(value) {
      _classCallCheck(this, TypeInferedList);

      _get(Object.getPrototypeOf(TypeInferedList.prototype), 'constructor', this).call(this);
      return TypeInferedList.prototype[$read](value);
    }

    _createClass(TypeInferedList, [{
      key: _typed.Typed.init,
      value: function value() {
        var result = (0, _typed.construct)(this).asMutable();
        result[$type] = new TypeInferer();
        return result;
      }
    }, {
      key: _typed.Typed.result,
      value: function value(result) {
        var list = result.asImmutable();
        list[$type] = result[$type].type;

        return list;
      }
    }, {
      key: _typed.Typed.read,
      value: function value(input) {
        var Type = this.constructor;

        if (input === null || input === void 0) {
          if (!this[$empty]) {
            var result = (0, _typed.construct)(this);
            result[$store] = ImmutableList();
            result.size = 0;
            this[$empty] = result;
          }

          return this[$empty];
        }

        if (input instanceof Type && input && input.constructor === Type) {
          return input;
        }

        var source = Indexed(input);
        var isEmpty = source.size === 0;

        if (isEmpty && this[$empty]) {
          return this[$empty];
        }

        var list = this[$init]();
        list.size = source.size;
        source.forEach(function (value, index) {
          list.set(index, value);
        });

        list = this[$result](list);

        if (isEmpty) {
          this[$empty] = list;
        }

        return list;
      }
    }, {
      key: _typed.Typed.step,
      value: function value(result, _ref) {
        var _ref2 = _slicedToArray(_ref, 2);

        var key = _ref2[0];
        var _value2 = _ref2[1];

        return change(result, function () {
          var store = arguments.length <= 0 || arguments[0] === undefined ? ImmutableList() : arguments[0];
          return store.set(key, _value2);
        });
      }
    }, {
      key: _typed.Typed.typeName,
      value: function value() {
        return this[$label] || 'Typed.List(' + this[$type][$typeName]() + ')';
      }
    }, {
      key: 'toString',
      value: function toString() {
        return this.__toString(this[$typeName]() + '([', '])');
      }
    }, {
      key: 'has',
      value: function has(key) {
        return this[$store].has(key);
      }
    }, {
      key: 'get',
      value: function get(index, notSetValue) {
        return this[$store] ? this[$store].get(index, notSetValue) : notSetValue;
      }
    }, {
      key: 'clear',
      value: function clear() {
        if (this.__ownerID) {
          return change(this, _clear);
        }

        return this[$empty] || this[$read]();
      }
    }, {
      key: 'remove',
      value: function remove(index) {
        return change(this, function (store) {
          return store && store.remove(index);
        });
      }
    }, {
      key: 'set',
      value: function set(index, value) {
        if (index > this.size) {
          throw TypeError('Index "' + index + '" is out of bound');
        }

        var result = this[$type][$read](value);

        if (result instanceof TypeError) {
          throw TypeError('Invalid value: ' + result.message);
        }

        return this[$step](this, [index, result]);
      }
    }, {
      key: 'push',
      value: function push() {
        var type = this[$type];
        var items = [];

        for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
          values[_key] = arguments[_key];
        }

        var count = values.length;
        var index = 0;
        while (index < count) {
          var value = values[index];
          var result = type[$read](value);

          if (result instanceof TypeError) {
            throw TypeError('Invalid value: ' + result.message);
          }

          items.push(result);
          index = index + 1;
        }

        return change(this, function (store) {
          return store ? store.push.apply(store, items) : ImmutableList.apply(undefined, items);
        });
      }
    }, {
      key: 'pop',
      value: function pop() {
        return change(this, _pop);
      }
    }, {
      key: 'unshift',
      value: function unshift() {
        var type = this[$type];
        var items = [];

        for (var _len2 = arguments.length, values = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          values[_key2] = arguments[_key2];
        }

        var count = values.length;
        var index = 0;

        while (index < count) {
          var value = values[index];
          var result = type[$read](value);

          if (result instanceof TypeError) {
            throw TypeError('Invalid value: ' + result.message);
          }

          items.push(result);
          index = index + 1;
        }

        return change(this, function (store) {
          return store ? store.unshift.apply(store, items) : ImmutableList.apply(undefined, items);
        });
      }
    }, {
      key: 'shift',
      value: function shift() {
        return change(this, _shift);
      }
    }, {
      key: 'setSize',
      value: function setSize(size) {
        if (size > this.size) {
          throw TypeError('setSize may only downsize');
        }

        return change(this, function (store) {
          return store.setSize(size);
        });
      }
    }, {
      key: 'slice',
      value: function slice(begin, end) {
        return change(this, function (store) {
          return store && store.slice(begin, end);
        });
      }
    }, {
      key: 'wasAltered',
      value: function wasAltered() {
        return this[$store].wasAltered();
      }
    }, {
      key: '__ensureOwner',
      value: function __ensureOwner(ownerID) {
        var result = this.__ownerID === ownerID ? this : !ownerID ? this : (0, _typed.construct)(this);

        result.__ownerID = ownerID;
        result[$store] = this[$store] ? this[$store].__ensureOwner(ownerID) : ImmutableList().__ensureOwner(ownerID);
        result.size = result[$store].size;

        return result;
      }
    }, {
      key: '__iterator',
      value: function __iterator(type, reverse) {
        var _this = this;

        return Indexed(this[$store]).map(function (_, key) {
          return _this.get(key);
        }).__iterator(type, reverse);
      }
    }, {
      key: '__iterate',
      value: function __iterate(f, reverse) {
        var _this2 = this;

        return Indexed(this[$store]).map(function (_, key) {
          return _this2.get(key);
        }).__iterate(f, reverse);
      }
    }]);

    return TypeInferedList;
  })(BaseImmutableList);

  TypeInferedList.prototype[_typed.Typed.DELETE] = TypeInferedList.prototype.remove;

  var BaseTypeInferedList = function BaseTypeInferedList() {};
  BaseTypeInferedList.prototype = TypeInferedList.prototype;

  var TypedList = (function (_BaseTypeInferedList) {
    function TypedList() {
      _classCallCheck(this, TypedList);

      _get(Object.getPrototypeOf(TypedList.prototype), 'constructor', this).call(this);
    }

    _inherits(TypedList, _BaseTypeInferedList);

    _createClass(TypedList, [{
      key: _typed.Typed.init,
      value: function value() {
        return (0, _typed.construct)(this).asMutable();
      }
    }, {
      key: _typed.Typed.result,
      value: function value(result) {
        return result.asImmutable();
      }
    }, {
      key: 'map',
      value: function map(mapper, context) {
        if (this.size === 0) {
          return this;
        } else {
          var result = TypeInferedList.from(this).map(mapper, context);
          if (this[$store] === result[$store]) {
            return this;
          }
          if (result[$type] === this[$type]) {
            var list = (0, _typed.construct)(this);
            list[$store] = result[$store];
            list.size = result.size;
            return list;
          } else {
            return result;
          }
        }
      }
    }]);

    return TypedList;
  })(BaseTypeInferedList);

  var List = function List(descriptor, label) {
    var _Object$create;

    if (descriptor === void 0) {
      throw TypeError('Typed.List must be passed a type descriptor');
    }

    if (descriptor === _typed.Any) {
      return _immutable.List;
    }

    var type = (0, _typed.typeOf)(descriptor);

    if (type === _typed.Any) {
      throw TypeError('Typed.List was passed an invalid type descriptor: ${descriptor}');
    }

    var ListType = function ListType(value) {
      var isListType = this instanceof ListType;
      var Type = isListType ? this.constructor : ListType;

      if (value instanceof Type) {
        return value;
      }

      var result = Type.prototype[$read](value);

      if (result instanceof TypeError) {
        throw result;
      }

      // `list.map(f)` will in fact cause `list.constructor(items)` to be
      // invoked there for we need to check if `this[$store]` was
      // assigned to know if it's that or if it's a `new ListType()` call.
      if (isListType && !this[$store]) {
        this[$store] = result[$store];
        this.size = result.size;
      } else {
        return result;
      }

      return this;
    };
    ListType.of = ImmutableList.of;
    ListType.prototype = Object.create(ListPrototype, (_Object$create = {
      constructor: { value: ListType }
    }, _defineProperty(_Object$create, $type, { value: type }), _defineProperty(_Object$create, $label, { value: label }), _Object$create));

    return ListType;
  };
  exports.List = List;
  List.Type = TypedList;
  List.prototype = TypedList.prototype;
  var ListPrototype = TypedList.prototype;
});
//# sourceMappingURL=data:application/json;base64,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QUFBO0FBQ3BDLE1BQU0sYUFBYSxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUEiLCJmaWxlIjoibGlzdC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7VHlwZWQsIFR5cGUsIFVuaW9uLCBBbnksIHR5cGVPZiwgY29uc3RydWN0fSBmcm9tIFwiLi90eXBlZFwiXG5pbXBvcnQgKiBhcyBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJ1xuXG5cbmNvbnN0IEltbXV0YWJsZUxpc3QgPSBJbW11dGFibGUuTGlzdFxuY29uc3Qge0luZGV4ZWR9ID0gSW1tdXRhYmxlLkl0ZXJhYmxlXG5cbmNvbnN0ICRzdG9yZSA9IFR5cGVkLnN0b3JlXG5jb25zdCAkdHlwZSA9IFR5cGVkLnR5cGVcbmNvbnN0ICRyZWFkID0gVHlwZWQucmVhZFxuY29uc3QgJHN0ZXAgPSBUeXBlZC5zdGVwXG5jb25zdCAkaW5pdCA9IFR5cGVkLmluaXRcbmNvbnN0ICRyZXN1bHQgPSBUeXBlZC5yZXN1bHRcbmNvbnN0ICRsYWJlbCA9IFR5cGVkLmxhYmVsXG5jb25zdCAkdHlwZU5hbWUgPSBUeXBlZC50eXBlTmFtZVxuY29uc3QgJGVtcHR5ID0gVHlwZWQuZW1wdHlcblxuXG5jb25zdCBjaGFuZ2UgPSAobGlzdCwgZikgPT4ge1xuICBjb25zdCBzdG9yZSA9IGYobGlzdFskc3RvcmVdKVxuICBpZiAoc3RvcmUgPT09IGxpc3RbJHN0b3JlXSkge1xuICAgIHJldHVybiBsaXN0XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbGlzdC5fX293bmVySUQgPyBsaXN0IDogY29uc3RydWN0KGxpc3QpXG4gICAgcmVzdWx0WyRzdG9yZV0gPSBzdG9yZVxuICAgIHJlc3VsdC5zaXplID0gc3RvcmUuc2l6ZVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5jb25zdCBjbGVhciA9IHRhcmdldCA9PiB0YXJnZXQuY2xlYXIoKVxuY29uc3QgcG9wID0gdGFyZ2V0ID0+IHRhcmdldC5wb3AoKVxuY29uc3Qgc2hpZnQgPSB0YXJnZXQgPT4gdGFyZ2V0LnNoaWZ0KClcblxuY2xhc3MgVHlwZUluZmVyZXIgZXh0ZW5kcyBUeXBlIHtcbiAgW1R5cGVkLnR5cGVOYW1lXSgpIHtcbiAgICByZXR1cm4gJ1R5cGVJbmZlcmVyJ1xuICB9XG4gIFtUeXBlZC5yZWFkXSh2YWx1ZSkge1xuICAgIC8vIHR5cGVPZiB1c3VhbGx5IGNyZWF0ZXMgdHlwZSBmb3IgdGhlIHZhbHVlIHdpdGggdGhhdFxuICAgIC8vIHZhbHVlIGJlaW5nIGEgZGVmYXVsdC4gRm9yIHR5cGUgaW5mZXJlbmNlIHdlIHNob3VsZFxuICAgIC8vIGFjdHVhbGx5IHVzZSBhIGJhc2UgdHlwZSBpbnN0ZWFkIG9mIHR5cGUgd2l0aCBkZWZhdWx0XG4gICAgLy8gdGhlcmUgZm9yIHdlIHVzZSBwcm90b3R5cGUgb2YgdGhlIGNvbnN0cnVjdG9yLlxuICAgIGNvbnN0IHR5cGUgPSB0eXBlT2YodmFsdWUpLmNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICAgIHRoaXMudHlwZSA9IHRoaXMudHlwZSA/IFVuaW9uKHRoaXMudHlwZSwgdHlwZSkgOiB0eXBlXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cblxuZnVuY3Rpb24gQmFzZUltbXV0YWJsZUxpc3QoKSB7fVxuQmFzZUltbXV0YWJsZUxpc3QucHJvdG90eXBlID0gSW1tdXRhYmxlTGlzdC5wcm90b3R5cGVcblxuY2xhc3MgVHlwZUluZmVyZWRMaXN0IGV4dGVuZHMgQmFzZUltbXV0YWJsZUxpc3Qge1xuICBzdGF0aWMgZnJvbShsaXN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY29uc3RydWN0KHRoaXMucHJvdG90eXBlKVxuICAgIHJlc3VsdFskc3RvcmVdID0gbGlzdFskc3RvcmVdXG4gICAgcmVzdWx0LnNpemUgPSBsaXN0LnNpemVcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHJldHVybiBUeXBlSW5mZXJlZExpc3QucHJvdG90eXBlWyRyZWFkXSh2YWx1ZSlcbiAgfVxuICBbVHlwZWQuaW5pdF0oKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY29uc3RydWN0KHRoaXMpLmFzTXV0YWJsZSgpXG4gICAgcmVzdWx0WyR0eXBlXSA9IG5ldyBUeXBlSW5mZXJlcigpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG4gIFtUeXBlZC5yZXN1bHRdKHJlc3VsdCkge1xuICAgIGNvbnN0IGxpc3QgPSByZXN1bHQuYXNJbW11dGFibGUoKVxuICAgIGxpc3RbJHR5cGVdID0gcmVzdWx0WyR0eXBlXS50eXBlXG5cbiAgICByZXR1cm4gbGlzdFxuICB9XG5cbiAgW1R5cGVkLnJlYWRdKGlucHV0KSB7XG4gICAgY29uc3QgVHlwZSA9IHRoaXMuY29uc3RydWN0b3JcblxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCgwKSkge1xuICAgICAgaWYgKCF0aGlzWyRlbXB0eV0pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY29uc3RydWN0KHRoaXMpXG4gICAgICAgIHJlc3VsdFskc3RvcmVdID0gSW1tdXRhYmxlTGlzdCgpXG4gICAgICAgIHJlc3VsdC5zaXplID0gMFxuICAgICAgICB0aGlzWyRlbXB0eV0gPSByZXN1bHRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNbJGVtcHR5XVxuICAgIH1cblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFR5cGUgJiYgaW5wdXQgJiYgaW5wdXQuY29uc3RydWN0b3IgPT09IFR5cGUpIHtcbiAgICAgIHJldHVybiBpbnB1dFxuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IEluZGV4ZWQoaW5wdXQpXG4gICAgY29uc3QgaXNFbXB0eSA9IHNvdXJjZS5zaXplID09PSAwXG5cbiAgICBpZiAoaXNFbXB0eSAmJiB0aGlzWyRlbXB0eV0pIHtcbiAgICAgIHJldHVybiB0aGlzWyRlbXB0eV1cbiAgICB9XG5cblxuICAgIGxldCBsaXN0ID0gdGhpc1skaW5pdF0oKVxuICAgIGxpc3Quc2l6ZSA9IHNvdXJjZS5zaXplXG4gICAgc291cmNlLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgbGlzdC5zZXQoaW5kZXgsIHZhbHVlKVxuICAgIH0pXG5cbiAgICBsaXN0ID0gdGhpc1skcmVzdWx0XShsaXN0KVxuXG4gICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgIHRoaXNbJGVtcHR5XSA9IGxpc3RcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdFxuICB9XG4gIFtUeXBlZC5zdGVwXShyZXN1bHQsIFtrZXksIHZhbHVlXSkge1xuICAgIHJldHVybiBjaGFuZ2UocmVzdWx0LCAoc3RvcmU9SW1tdXRhYmxlTGlzdCgpKSA9PiBzdG9yZS5zZXQoa2V5LCB2YWx1ZSkpXG4gIH1cblxuICBbVHlwZWQudHlwZU5hbWVdKCkge1xuICAgIHJldHVybiB0aGlzWyRsYWJlbF0gfHwgYFR5cGVkLkxpc3QoJHt0aGlzWyR0eXBlXVskdHlwZU5hbWVdKCl9KWBcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcodGhpc1skdHlwZU5hbWVdKCkgKyAnKFsnLCAnXSknKVxuICB9XG5cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiB0aGlzWyRzdG9yZV0uaGFzKGtleSlcbiAgfVxuXG4gIGdldChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpc1skc3RvcmVdID8gdGhpc1skc3RvcmVdLmdldChpbmRleCwgbm90U2V0VmFsdWUpIDpcbiAgICAgICAgICAgbm90U2V0VmFsdWVcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIGNoYW5nZSh0aGlzLCBjbGVhcilcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1skZW1wdHldIHx8IHRoaXNbJHJlYWRdKClcbiAgfVxuXG4gIHJlbW92ZShpbmRleCkge1xuICAgIHJldHVybiBjaGFuZ2UodGhpcywgc3RvcmUgPT4gc3RvcmUgJiYgc3RvcmUucmVtb3ZlKGluZGV4KSlcbiAgfVxuXG4gIHNldChpbmRleCwgdmFsdWUpIHtcbiAgICBpZiAoaW5kZXggPiB0aGlzLnNpemUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcihgSW5kZXggXCIke2luZGV4fVwiIGlzIG91dCBvZiBib3VuZGApXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpc1skdHlwZV1bJHJlYWRdKHZhbHVlKVxuXG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlOiAke3Jlc3VsdC5tZXNzYWdlfWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNbJHN0ZXBdKHRoaXMsIFtpbmRleCwgcmVzdWx0XSlcbiAgfVxuXG4gIHB1c2goLi4udmFsdWVzKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXNbJHR5cGVdXG4gICAgY29uc3QgaXRlbXMgPSBbXVxuICAgIGNvbnN0IGNvdW50ID0gdmFsdWVzLmxlbmd0aFxuICAgIGxldCBpbmRleCA9IDBcbiAgICB3aGlsZSAoaW5kZXggPCBjb3VudCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdXG4gICAgICBjb25zdCByZXN1bHQgPSB0eXBlWyRyZWFkXSh2YWx1ZSlcblxuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWU6ICR7cmVzdWx0Lm1lc3NhZ2V9YClcbiAgICAgIH1cblxuICAgICAgaXRlbXMucHVzaChyZXN1bHQpXG4gICAgICBpbmRleCA9IGluZGV4ICsgMVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2UodGhpcywgc3RvcmUgPT5cbiAgICAgIHN0b3JlID8gc3RvcmUucHVzaCguLi5pdGVtcykgOiBJbW11dGFibGVMaXN0KC4uLml0ZW1zKSlcbiAgfVxuICBwb3AoKSB7XG4gICAgcmV0dXJuIGNoYW5nZSh0aGlzLCBwb3ApXG4gIH1cbiAgdW5zaGlmdCguLi52YWx1ZXMpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpc1skdHlwZV1cbiAgICBjb25zdCBpdGVtcyA9IFtdXG4gICAgY29uc3QgY291bnQgPSB2YWx1ZXMubGVuZ3RoXG4gICAgbGV0IGluZGV4ID0gMFxuXG4gICAgd2hpbGUgKGluZGV4IDwgY291bnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XVxuICAgICAgY29uc3QgcmVzdWx0ID0gdHlwZVskcmVhZF0odmFsdWUpXG5cbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlOiAke3Jlc3VsdC5tZXNzYWdlfWApXG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2gocmVzdWx0KVxuICAgICAgaW5kZXggPSBpbmRleCArIDFcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlKHRoaXMsIHN0b3JlID0+XG4gICAgICBzdG9yZSA/IHN0b3JlLnVuc2hpZnQoLi4uaXRlbXMpIDogSW1tdXRhYmxlTGlzdCguLi5pdGVtcykpXG4gIH1cbiAgc2hpZnQoKSB7XG4gICAgcmV0dXJuIGNoYW5nZSh0aGlzLCBzaGlmdClcbiAgfVxuICBzZXRTaXplKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA+IHRoaXMuc2l6ZSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKGBzZXRTaXplIG1heSBvbmx5IGRvd25zaXplYClcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlKHRoaXMsIHN0b3JlID0+IHN0b3JlLnNldFNpemUoc2l6ZSkpXG4gIH1cbiAgc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgIHJldHVybiBjaGFuZ2UodGhpcywgc3RvcmUgPT4gc3RvcmUgJiYgc3RvcmUuc2xpY2UoYmVnaW4sIGVuZCkpXG4gIH1cblxuICB3YXNBbHRlcmVkKCkge1xuICAgIHJldHVybiB0aGlzWyRzdG9yZV0ud2FzQWx0ZXJlZCgpXG4gIH1cblxuICBfX2Vuc3VyZU93bmVyKG93bmVySUQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9fb3duZXJJRCA9PT0gb3duZXJJRCA/IHRoaXMgOlxuICAgICAgICAgICAgICAgICAgICFvd25lcklEID8gdGhpcyA6XG4gICAgICAgICAgICAgICAgICAgY29uc3RydWN0KHRoaXMpXG5cbiAgICByZXN1bHQuX19vd25lcklEID0gb3duZXJJRFxuICAgIHJlc3VsdFskc3RvcmVdID0gdGhpc1skc3RvcmVdID8gdGhpc1skc3RvcmVdLl9fZW5zdXJlT3duZXIob3duZXJJRCkgOlxuICAgICAgICAgICAgICAgICAgICAgSW1tdXRhYmxlTGlzdCgpLl9fZW5zdXJlT3duZXIob3duZXJJRClcbiAgICByZXN1bHQuc2l6ZSA9IHJlc3VsdFskc3RvcmVdLnNpemVcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuICBfX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpIHtcbiAgICByZXR1cm4gSW5kZXhlZCh0aGlzWyRzdG9yZV0pLm1hcCgoXywga2V5KSA9PiB0aGlzLmdldChrZXkpKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpXG4gIH1cblxuICBfX2l0ZXJhdGUoZiwgcmV2ZXJzZSkge1xuICAgIHJldHVybiBJbmRleGVkKHRoaXNbJHN0b3JlXSkubWFwKChfLCBrZXkpID0+IHRoaXMuZ2V0KGtleSkpLl9faXRlcmF0ZShmLCByZXZlcnNlKVxuICB9XG59XG5UeXBlSW5mZXJlZExpc3QucHJvdG90eXBlW1R5cGVkLkRFTEVURV0gPSBUeXBlSW5mZXJlZExpc3QucHJvdG90eXBlLnJlbW92ZTtcblxuY29uc3QgQmFzZVR5cGVJbmZlcmVkTGlzdCA9IGZ1bmN0aW9uKCkge31cbkJhc2VUeXBlSW5mZXJlZExpc3QucHJvdG90eXBlID0gVHlwZUluZmVyZWRMaXN0LnByb3RvdHlwZVxuXG5jbGFzcyBUeXBlZExpc3QgZXh0ZW5kcyBCYXNlVHlwZUluZmVyZWRMaXN0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKVxuICB9XG4gIFtUeXBlZC5pbml0XSgpIHtcbiAgICByZXR1cm4gY29uc3RydWN0KHRoaXMpLmFzTXV0YWJsZSgpXG4gIH1cbiAgW1R5cGVkLnJlc3VsdF0ocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdC5hc0ltbXV0YWJsZSgpXG4gIH1cbiAgbWFwKG1hcHBlciwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFR5cGVJbmZlcmVkTGlzdC5mcm9tKHRoaXMpLm1hcChtYXBwZXIsIGNvbnRleHQpXG4gICAgICBpZiAodGhpc1skc3RvcmVdID09PSByZXN1bHRbJHN0b3JlXSkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdFskdHlwZV0gPT09IHRoaXNbJHR5cGVdKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBjb25zdHJ1Y3QodGhpcylcbiAgICAgICAgbGlzdFskc3RvcmVdID0gcmVzdWx0WyRzdG9yZV1cbiAgICAgICAgbGlzdC5zaXplID0gcmVzdWx0LnNpemVcbiAgICAgICAgcmV0dXJuIGxpc3RcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IExpc3QgPSBmdW5jdGlvbihkZXNjcmlwdG9yLCBsYWJlbCkge1xuICBpZiAoZGVzY3JpcHRvciA9PT0gdm9pZCgwKSkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIlR5cGVkLkxpc3QgbXVzdCBiZSBwYXNzZWQgYSB0eXBlIGRlc2NyaXB0b3JcIilcbiAgfVxuXG4gIGlmIChkZXNjcmlwdG9yID09PSBBbnkpIHtcbiAgICByZXR1cm4gSW1tdXRhYmxlLkxpc3RcbiAgfVxuXG4gIGNvbnN0IHR5cGUgPSB0eXBlT2YoZGVzY3JpcHRvcilcblxuICBpZiAodHlwZSA9PT0gQW55KSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiVHlwZWQuTGlzdCB3YXMgcGFzc2VkIGFuIGludmFsaWQgdHlwZSBkZXNjcmlwdG9yOiAke2Rlc2NyaXB0b3J9XCIpXG4gIH1cblxuICBjb25zdCBMaXN0VHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3QgaXNMaXN0VHlwZSA9IHRoaXMgaW5zdGFuY2VvZiBMaXN0VHlwZVxuICAgIGNvbnN0IFR5cGUgPSBpc0xpc3RUeXBlID8gdGhpcy5jb25zdHJ1Y3RvciA6IExpc3RUeXBlXG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBUeXBlLnByb3RvdHlwZVskcmVhZF0odmFsdWUpXG5cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICB0aHJvdyByZXN1bHRcbiAgICB9XG5cbiAgICAvLyBgbGlzdC5tYXAoZilgIHdpbGwgaW4gZmFjdCBjYXVzZSBgbGlzdC5jb25zdHJ1Y3RvcihpdGVtcylgIHRvIGJlXG4gICAgLy8gaW52b2tlZCB0aGVyZSBmb3Igd2UgbmVlZCB0byBjaGVjayBpZiBgdGhpc1skc3RvcmVdYCB3YXNcbiAgICAvLyBhc3NpZ25lZCB0byBrbm93IGlmIGl0J3MgdGhhdCBvciBpZiBpdCdzIGEgYG5ldyBMaXN0VHlwZSgpYCBjYWxsLlxuICAgIGlmIChpc0xpc3RUeXBlICYmICF0aGlzWyRzdG9yZV0pIHtcbiAgICAgIHRoaXNbJHN0b3JlXSA9IHJlc3VsdFskc3RvcmVdXG4gICAgICB0aGlzLnNpemUgPSByZXN1bHQuc2l6ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICBMaXN0VHlwZS5vZiA9IEltbXV0YWJsZUxpc3Qub2ZcbiAgTGlzdFR5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMaXN0UHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHt2YWx1ZTogTGlzdFR5cGV9LFxuICAgIFskdHlwZV06IHt2YWx1ZTogdHlwZX0sXG4gICAgWyRsYWJlbF06IHt2YWx1ZTogbGFiZWx9XG4gIH0pXG5cbiAgcmV0dXJuIExpc3RUeXBlXG59XG5MaXN0LlR5cGUgPSBUeXBlZExpc3Rcbkxpc3QucHJvdG90eXBlID0gVHlwZWRMaXN0LnByb3RvdHlwZVxuY29uc3QgTGlzdFByb3RvdHlwZSA9IFR5cGVkTGlzdC5wcm90b3R5cGVcbiJdfQ==