(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['exports', 'immutable'], factory);
  } else if (typeof exports !== 'undefined') {
    factory(exports, require('immutable'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.Immutable);
    global.typed = mod.exports;
  }
})(this, function (exports, _immutable) {
  'use strict';

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

  function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _defaults(subClass, superClass); }

  if (typeof Symbol === 'undefined') {
    var Symbol = function Symbol(hint) {
      return '@@' + hint;
    };
    Symbol['for'] = Symbol;
  }

  function Construct() {}
  var construct = function construct(value) {
    Construct.prototype = value.constructor.prototype;
    return new Construct();
  };

  exports.construct = construct;
  var $type = Symbol['for']('typed/type');
  var $store = Symbol['for']('typed/store');
  var $empty = Symbol['for']('typed/empty');

  var $maybe = Symbol['for']('typed/type/maybe');
  var $default = Symbol['for']('typed/type/default');
  var $label = Symbol['for']('typed/type/label');

  var $init = Symbol['for']('transducer/init');
  var $result = Symbol['for']('transducer/result');
  var $step = Symbol['for']('transducer/step');
  var $read = Symbol['for']('typed/type/read');
  var $parse = Symbol['for']('typed/type/parse');
  var $typeName = Symbol('typed/type/name');
  var $typeSignature = Symbol('typed/type/signature');

  var Typed = function Typed(label, parse, defaultValue) {
    var ValueType = (function (_Type) {
      function ValueType(defaultValue) {
        _classCallCheck(this, ValueType);

        _get(Object.getPrototypeOf(ValueType.prototype), 'constructor', this).call(this);
        this[$default] = defaultValue;
      }

      _inherits(ValueType, _Type);

      return ValueType;
    })(Type);

    var prototype = ValueType.prototype;
    prototype[$default] = defaultValue;
    prototype[$parse] = parse;
    prototype[$label] = label;

    var TypedValue = function TypedValue(defaultValue) {
      return defaultValue === void 0 ? prototype : new ValueType(defaultValue);
    };
    TypedValue.prototype = prototype;

    return TypedValue;
  };

  exports.Typed = Typed;
  Typed.label = $label;
  Typed.defaultValue = $default;
  Typed.read = $read;
  Typed.typeName = $typeName;
  Typed.typeSignature = $typeSignature;

  Typed.type = $type;
  Typed.store = $store;
  Typed.init = $init;
  Typed.result = $result;
  Typed.step = $step;
  Typed.DELETE = 'delete';
  Typed.empty = $empty;

  var typeName = function typeName(type) {
    return type[$typeName]();
  };
  var typeSignature = function typeSignature(type) {
    return type[$typeSignature]();
  };

  var Type = (function () {
    function Type() {
      _classCallCheck(this, Type);
    }

    _createClass(Type, [{
      key: Typed.read,
      value: function value() {
        var _value = arguments.length <= 0 || arguments[0] === undefined ? this[$default] : arguments[0];

        return this[$parse](_value);
      }
    }, {
      key: Typed.parse,
      value: function value(_value2) {
        throw TypeError('Type implementation must implement "[read.symbol]" method');
      }
    }, {
      key: Typed.typeName,
      value: function value() {
        var label = this[$label];
        var defaultValue = this[$default];
        return defaultValue === void 0 ? label : label + '(' + JSON.stringify(defaultValue) + ')';
      }
    }]);

    return Type;
  })();

  exports.Type = Type;

  var ObjectPrototype = Object.prototype;

  // Returns `true` if given `x` is a JS array.
  var isArray = Array.isArray || function (x) {
    return ObjectPrototype.toString.call(x) === '[object Array]';
  };

  // Returns `true` if given `x` is a regular expression.
  var isRegExp = function isRegExp(x) {
    return ObjectPrototype.toString.call(x) === '[object RegExp]';
  };

  var typeOf = function typeOf(x) {
    var type = arguments.length <= 1 || arguments[1] === undefined ? typeof x : arguments[1];
    return (function () {
      return x === void 0 ? x : x === null ? x : x[$read] ? x : x.prototype && x.prototype[$read] ? x.prototype : type === 'number' ? new Typed.Number(x) : type === 'string' ? new Typed.String(x) : type === 'boolean' ? new Typed.Boolean(x) : type === 'symbol' ? new Typed.Symbol(x) : isArray(x) ? Typed.Array(x) : isRegExp(x) ? new Typed.RegExp(x) : x === String ? Typed.String.prototype : x === Number ? Typed.Number.prototype : x === Boolean ? Typed.Boolean.prototype : x === RegExp ? Typed.RegExp.prototype : x === Array ? Typed.Array.prototype : x === Symbol ? Typed.Symbol.prototype : x === Date ? Typed.Date.prototype : Any;
    })();
  };

  exports.typeOf = typeOf;
  var Any = Typed('Any', function (value) {
    return value;
  })();
  exports.Any = Any;
  Typed.Any = Any;

  Typed.Number = Typed('Number', function (value) {
    return typeof value === 'number' ? value : TypeError('"' + value + '" is not a number');
  });

  Typed.String = Typed('String', function (value) {
    return typeof value === 'string' ? value : TypeError('"' + value + '" is not a string');
  });

  Typed.Symbol = Typed('Symbol', function (value) {
    return typeof value === 'symbol' ? value : TypeError('"' + value + '" is not a symbol');
  });

  Typed.Array = Typed('Array', function (value) {
    return isArray(value) ? value : TypeError('"' + value + '" is not an array');
  });

  Typed.RegExp = Typed('RegExp', function (value) {
    return value instanceof RegExp ? value : TypeError('"' + value + '" is not a regexp');
  });

  Typed.Boolean = Typed('Boolean', function (value) {
    return value === true ? true : value === false ? false : TypeError('"' + value + '" is not a boolean');
  });

  var MaybeType = (function (_Type2) {
    function MaybeType(type) {
      _classCallCheck(this, MaybeType);

      _get(Object.getPrototypeOf(MaybeType.prototype), 'constructor', this).call(this);
      this[$type] = type;
    }

    _inherits(MaybeType, _Type2);

    _createClass(MaybeType, [{
      key: Typed.typeName,
      value: function value() {
        return 'Maybe(' + this[$type][$typeName]() + ')';
      }
    }, {
      key: Typed.read,
      value: function value(_value3) {
        var result = _value3 == null ? null : this[$type][$read](_value3);

        return !(result instanceof TypeError) ? result : TypeError('"' + _value3 + '" is not nully nor it is of ' + this[$type][$typeName]() + ' type');
      }
    }]);

    return MaybeType;
  })(Type);

  var Maybe = function Maybe(Type) {
    var type = typeOf(Type);
    if (type === Any) {
      throw TypeError(Type + ' is not a valid type');
    }

    return type[$maybe] || (type[$maybe] = new MaybeType(type));
  };
  exports.Maybe = Maybe;
  Maybe.Type = MaybeType;

  var UnionType = (function (_Type3) {
    function UnionType(variants) {
      _classCallCheck(this, UnionType);

      _get(Object.getPrototypeOf(UnionType.prototype), 'constructor', this).call(this);
      this[$type] = variants;
    }

    _inherits(UnionType, _Type3);

    _createClass(UnionType, [{
      key: Typed.typeName,
      value: function value() {
        return 'Union(' + this[$type].map(typeName).join(', ') + ')';
      }
    }, {
      key: Typed.read,
      value: function value(_value4) {
        var variants = this[$type];
        var count = variants.length;
        var index = 0;
        while (index < count) {
          var variant = variants[index];
          if (_value4 instanceof variant.constructor) {
            return _value4;
          }
          index = index + 1;
        }

        index = 0;
        while (index < count) {
          var result = variants[index][$read](_value4);
          if (!(result instanceof TypeError)) {
            return result;
          }
          index = index + 1;
        }

        return TypeError('"' + _value4 + '" does not satisfy ' + this[$typeName]() + ' type');
      }
    }]);

    return UnionType;
  })(Type);

  // Returns `xs` excluding any values that are included in `ys`.
  var subtract = function subtract(xs, ys) {
    return xs.filter(function (x) {
      return ys.indexOf(x) < 0;
    });
  };

  // Returns array including all values from `xs` and all values from
  // `ys` that aren't already included in `xs`. It will also attempt
  // to return either `xs` or `ys` if one of them is a superset of other.
  // return `xs` or `ys` if
  var union = function union(xs, ys) {
    // xs can be superset only if it contains more items then
    // ys. If that's a case find items in ys that arent included
    // in xs. If such items do not exist return back `xs` otherwise
    // return concatination of xs with those items.
    // those items
    if (xs.length > ys.length) {
      var diff = subtract(ys, xs);
      return diff.length === 0 ? xs : xs.concat(diff);
    }
    // if number of items in xs is not greater than number of items in ys
    // then either xs is either subset or equal of `ys`. There for we find
    // ys that are not included in `xs` if such items aren't found ys is
    // either superset or equal so just return ys otherwise return concatination
    // of those items with `ys`.
    else {
      var diff = subtract(xs, ys);
      return diff.length === 0 ? ys : diff.concat(ys);
    }
  };

  var Union = function Union() {
    for (var _len = arguments.length, Types = Array(_len), _key = 0; _key < _len; _key++) {
      Types[_key] = arguments[_key];
    }

    var count = Types.length;

    if (count === 0) {
      throw TypeError('Union must be of at at least one type');
    }

    var variants = null;
    var type = null;
    var index = 0;
    while (index < count) {
      var variant = typeOf(Types[index]);
      // If there is `Any` present than union is also `Any`.
      if (variant === Any) {
        return Any;
      }
      // If this is the first type we met than we assume it's the
      // one that satisfies all types.
      if (!variants) {
        type = variant;
        variants = type instanceof UnionType ? type[$type] : [variant];
      } else if (variants.indexOf(variant) < 0) {
        // If current reader is of union type
        if (variant instanceof UnionType) {
          var variantUnion = union(variants, variant[$type]);

          // If `reader.readers` matches union of readers, then
          // current reader is a superset so we use it as a type
          // that satisfies all types.
          if (variantUnion === variant[$type]) {
            type = variant;
            variants = variantUnion;
          }
          // If current readers is not the union than it does not
          // satisfy currenty reader. There for we update readers
          // and unset a type.
          else if (variantUnion !== variants) {
            type = null;
            variants = variantUnion;
          }
        } else {
          type = null;
          variants.push(variant);
        }
      }

      index = index + 1;
    }

    return type ? type : new UnionType(variants);
  };
  exports.Union = Union;
  Union.Type = UnionType;

  Typed.Number.Range = function (from, to, defaultValue) {
    if (to === undefined) to = +Infinity;
    return Typed('Typed.Number.Range(' + from + '..' + to + ')', function (value) {
      if (typeof value !== 'number') {
        return TypeError('"' + value + '" is not a number');
      }

      if (!(value >= from && value <= to)) {
        return TypeError('"' + value + '" isn\'t in the range of ' + from + '..' + to);
      }

      return value;
    }, defaultValue);
  };
});
//# sourceMappingURL=data:application/json;base64,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LFVBQUssRUFBRSxDQUFHLENBQUE7T0FDcEU7O0FBRUQsYUFBTyxLQUFLLENBQUE7S0FDYixFQUFFLFlBQVksQ0FBQztHQUFBLENBQUEiLCJmaWxlIjoidHlwZWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBJbW11dGFibGUgZnJvbSAnaW1tdXRhYmxlJ1xuXG5pZiAodHlwZW9mKFN5bWJvbCkgPT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBTeW1ib2wgPSBoaW50ID0+IGBAQCR7aGludH1gXG4gIFN5bWJvbC5mb3IgPSBTeW1ib2xcbn1cblxuZnVuY3Rpb24gQ29uc3RydWN0KCkge31cbmV4cG9ydCBjb25zdCBjb25zdHJ1Y3QgPSB2YWx1ZSA9PiB7XG4gIENvbnN0cnVjdC5wcm90b3R5cGUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ldyBDb25zdHJ1Y3QoKVxufVxuXG5jb25zdCAkdHlwZSA9IFN5bWJvbC5mb3IoXCJ0eXBlZC90eXBlXCIpXG5jb25zdCAkc3RvcmUgPSBTeW1ib2wuZm9yKFwidHlwZWQvc3RvcmVcIilcbmNvbnN0ICRlbXB0eSA9IFN5bWJvbC5mb3IoXCJ0eXBlZC9lbXB0eVwiKVxuXG5jb25zdCAkbWF5YmUgPSBTeW1ib2wuZm9yKFwidHlwZWQvdHlwZS9tYXliZVwiKVxuY29uc3QgJGRlZmF1bHQgPSBTeW1ib2wuZm9yKFwidHlwZWQvdHlwZS9kZWZhdWx0XCIpXG5jb25zdCAkbGFiZWwgPSBTeW1ib2wuZm9yKFwidHlwZWQvdHlwZS9sYWJlbFwiKVxuXG5jb25zdCAkaW5pdCA9IFN5bWJvbC5mb3IoXCJ0cmFuc2R1Y2VyL2luaXRcIilcbmNvbnN0ICRyZXN1bHQgPSBTeW1ib2wuZm9yKFwidHJhbnNkdWNlci9yZXN1bHRcIilcbmNvbnN0ICRzdGVwID0gU3ltYm9sLmZvcihcInRyYW5zZHVjZXIvc3RlcFwiKVxuY29uc3QgJHJlYWQgPSBTeW1ib2wuZm9yKFwidHlwZWQvdHlwZS9yZWFkXCIpXG5jb25zdCAkcGFyc2UgPSBTeW1ib2wuZm9yKFwidHlwZWQvdHlwZS9wYXJzZVwiKVxuY29uc3QgJHR5cGVOYW1lID0gU3ltYm9sKFwidHlwZWQvdHlwZS9uYW1lXCIpXG5jb25zdCAkdHlwZVNpZ25hdHVyZSA9IFN5bWJvbChcInR5cGVkL3R5cGUvc2lnbmF0dXJlXCIpXG5cbmV4cG9ydCBjb25zdCBUeXBlZCA9IGZ1bmN0aW9uKGxhYmVsLCBwYXJzZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNsYXNzIFZhbHVlVHlwZSBleHRlbmRzIFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGRlZmF1bHRWYWx1ZSkge1xuICAgICAgc3VwZXIoKVxuICAgICAgdGhpc1skZGVmYXVsdF0gPSBkZWZhdWx0VmFsdWVcbiAgICB9XG4gIH1cblxuICBjb25zdCBwcm90b3R5cGUgPSBWYWx1ZVR5cGUucHJvdG90eXBlXG4gIHByb3RvdHlwZVskZGVmYXVsdF0gPSBkZWZhdWx0VmFsdWVcbiAgcHJvdG90eXBlWyRwYXJzZV0gPSBwYXJzZVxuICBwcm90b3R5cGVbJGxhYmVsXSA9IGxhYmVsXG5cbiAgY29uc3QgVHlwZWRWYWx1ZSA9IGZ1bmN0aW9uKGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWUgPT09IHZvaWQoMCkgPyBwcm90b3R5cGUgOlxuICAgIG5ldyBWYWx1ZVR5cGUoZGVmYXVsdFZhbHVlKVxuICB9XG4gIFR5cGVkVmFsdWUucHJvdG90eXBlID0gcHJvdG90eXBlXG5cbiAgcmV0dXJuIFR5cGVkVmFsdWVcbn1cblxuVHlwZWQubGFiZWwgPSAkbGFiZWxcblR5cGVkLmRlZmF1bHRWYWx1ZSA9ICRkZWZhdWx0XG5UeXBlZC5yZWFkID0gJHJlYWRcblR5cGVkLnR5cGVOYW1lID0gJHR5cGVOYW1lXG5UeXBlZC50eXBlU2lnbmF0dXJlID0gJHR5cGVTaWduYXR1cmVcblxuVHlwZWQudHlwZSA9ICR0eXBlXG5UeXBlZC5zdG9yZSA9ICRzdG9yZVxuVHlwZWQuaW5pdCA9ICRpbml0XG5UeXBlZC5yZXN1bHQgPSAkcmVzdWx0XG5UeXBlZC5zdGVwID0gJHN0ZXBcblR5cGVkLkRFTEVURSA9IFwiZGVsZXRlXCJcblR5cGVkLmVtcHR5ID0gJGVtcHR5XG5cbmNvbnN0IHR5cGVOYW1lID0gdHlwZSA9PiB0eXBlWyR0eXBlTmFtZV0oKVxuY29uc3QgdHlwZVNpZ25hdHVyZSA9IHR5cGUgPT4gdHlwZVskdHlwZVNpZ25hdHVyZV0oKVxuXG5leHBvcnQgY2xhc3MgVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge31cbiAgW1R5cGVkLnJlYWRdKHZhbHVlPXRoaXNbJGRlZmF1bHRdKSB7XG4gICAgcmV0dXJuIHRoaXNbJHBhcnNlXSh2YWx1ZSlcbiAgfVxuICBbVHlwZWQucGFyc2VdKHZhbHVlKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKGBUeXBlIGltcGxlbWVudGF0aW9uIG11c3QgaW1wbGVtZW50IFwiW3JlYWQuc3ltYm9sXVwiIG1ldGhvZGApXG4gIH1cbiAgW1R5cGVkLnR5cGVOYW1lXSgpIHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXNbJGxhYmVsXVxuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXNbJGRlZmF1bHRdXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSA9PT0gdm9pZCgwKSA/IGxhYmVsIDogYCR7bGFiZWx9KCR7SlNPTi5zdHJpbmdpZnkoZGVmYXVsdFZhbHVlKX0pYFxuICB9XG59XG5cbmNvbnN0IE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGVcblxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gYHhgIGlzIGEgSlMgYXJyYXkuXG5jb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fFxuICAoeCA9PiBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJylcblxuLy8gUmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gYHhgIGlzIGEgcmVndWxhciBleHByZXNzaW9uLlxuY29uc3QgaXNSZWdFeHAgPSB4ID0+XG4gIE9iamVjdFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXG5cbmV4cG9ydCBjb25zdCB0eXBlT2YgPSAoeCwgdHlwZT10eXBlb2YoeCkpID0+XG4gIHggPT09IHZvaWQoMCkgPyB4IDpcbiAgeCA9PT0gbnVsbCA/IHggOlxuICB4WyRyZWFkXSA/IHggOlxuICAoeC5wcm90b3R5cGUgJiYgeC5wcm90b3R5cGVbJHJlYWRdKSA/IHgucHJvdG90eXBlIDpcbiAgdHlwZSA9PT0gXCJudW1iZXJcIiA/IG5ldyBUeXBlZC5OdW1iZXIoeCkgOlxuICB0eXBlID09PSBcInN0cmluZ1wiID8gbmV3IFR5cGVkLlN0cmluZyh4KSA6XG4gIHR5cGUgPT09IFwiYm9vbGVhblwiID8gbmV3IFR5cGVkLkJvb2xlYW4oeCkgOlxuICB0eXBlID09PSBcInN5bWJvbFwiID8gbmV3IFR5cGVkLlN5bWJvbCh4KSA6XG4gIGlzQXJyYXkoeCkgPyBUeXBlZC5BcnJheSh4KSA6XG4gIGlzUmVnRXhwKHgpID8gbmV3IFR5cGVkLlJlZ0V4cCh4KSA6XG4gIHggPT09IFN0cmluZyA/IFR5cGVkLlN0cmluZy5wcm90b3R5cGUgOlxuICB4ID09PSBOdW1iZXIgPyBUeXBlZC5OdW1iZXIucHJvdG90eXBlIDpcbiAgeCA9PT0gQm9vbGVhbiA/IFR5cGVkLkJvb2xlYW4ucHJvdG90eXBlIDpcbiAgeCA9PT0gUmVnRXhwID8gVHlwZWQuUmVnRXhwLnByb3RvdHlwZSA6XG4gIHggPT09IEFycmF5ID8gVHlwZWQuQXJyYXkucHJvdG90eXBlIDpcbiAgeCA9PT0gU3ltYm9sID8gVHlwZWQuU3ltYm9sLnByb3RvdHlwZSA6XG4gIHggPT09IERhdGUgPyBUeXBlZC5EYXRlLnByb3RvdHlwZSA6XG4gIEFueTtcblxuZXhwb3J0IGNvbnN0IEFueSA9IFR5cGVkKFwiQW55XCIsIHZhbHVlID0+IHZhbHVlKSgpXG5UeXBlZC5BbnkgPSBBbnlcblxuVHlwZWQuTnVtYmVyID0gVHlwZWQoXCJOdW1iZXJcIiwgdmFsdWUgPT5cbiAgdHlwZW9mKHZhbHVlKSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlIDpcbiAgVHlwZUVycm9yKGBcIiR7dmFsdWV9XCIgaXMgbm90IGEgbnVtYmVyYCkpXG5cblR5cGVkLlN0cmluZyA9IFR5cGVkKFwiU3RyaW5nXCIsIHZhbHVlID0+XG4gIHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6XG4gIFR5cGVFcnJvcihgXCIke3ZhbHVlfVwiIGlzIG5vdCBhIHN0cmluZ2ApKVxuXG5UeXBlZC5TeW1ib2wgPSBUeXBlZChcIlN5bWJvbFwiLCB2YWx1ZSA9PlxuICB0eXBlb2YodmFsdWUpID09PSBcInN5bWJvbFwiID8gdmFsdWUgOlxuICBUeXBlRXJyb3IoYFwiJHt2YWx1ZX1cIiBpcyBub3QgYSBzeW1ib2xgKSlcblxuVHlwZWQuQXJyYXkgPSBUeXBlZChcIkFycmF5XCIsIHZhbHVlID0+XG4gIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOlxuICBUeXBlRXJyb3IoYFwiJHt2YWx1ZX1cIiBpcyBub3QgYW4gYXJyYXlgKSlcblxuVHlwZWQuUmVnRXhwID0gVHlwZWQoXCJSZWdFeHBcIiwgdmFsdWUgPT5cbiAgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgPyB2YWx1ZSA6XG4gIFR5cGVFcnJvcihgXCIke3ZhbHVlfVwiIGlzIG5vdCBhIHJlZ2V4cGApKVxuXG5UeXBlZC5Cb29sZWFuID0gVHlwZWQoXCJCb29sZWFuXCIsIHZhbHVlID0+XG4gIHZhbHVlID09PSB0cnVlID8gdHJ1ZSA6XG4gIHZhbHVlID09PSBmYWxzZSA/IGZhbHNlIDpcbiAgVHlwZUVycm9yKGBcIiR7dmFsdWV9XCIgaXMgbm90IGEgYm9vbGVhbmApKVxuXG5jbGFzcyBNYXliZVR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzWyR0eXBlXSA9IHR5cGVcbiAgfVxuICBbVHlwZWQudHlwZU5hbWVdKCkge1xuICAgIHJldHVybiBgTWF5YmUoJHt0aGlzWyR0eXBlXVskdHlwZU5hbWVdKCl9KWBcbiAgfVxuICBbVHlwZWQucmVhZF0odmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHRoaXNbJHR5cGVdWyRyZWFkXSh2YWx1ZSlcblxuICAgIHJldHVybiAhKHJlc3VsdCBpbnN0YW5jZW9mIFR5cGVFcnJvcikgPyByZXN1bHQgOlxuICAgICAgICAgICBUeXBlRXJyb3IoYFwiJHt2YWx1ZX1cIiBpcyBub3QgbnVsbHkgbm9yIGl0IGlzIG9mICR7dGhpc1skdHlwZV1bJHR5cGVOYW1lXSgpfSB0eXBlYClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTWF5YmUgPSBUeXBlID0+IHtcbiAgY29uc3QgdHlwZSA9IHR5cGVPZihUeXBlKVxuICBpZiAodHlwZSA9PT0gQW55KSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKGAke1R5cGV9IGlzIG5vdCBhIHZhbGlkIHR5cGVgKVxuICB9XG5cbiAgcmV0dXJuIHR5cGVbJG1heWJlXSB8fCAodHlwZVskbWF5YmVdID0gbmV3IE1heWJlVHlwZSh0eXBlKSlcbn1cbk1heWJlLlR5cGUgPSBNYXliZVR5cGVcblxuXG5jbGFzcyBVbmlvblR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgY29uc3RydWN0b3IodmFyaWFudHMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpc1skdHlwZV0gPSB2YXJpYW50c1xuICB9XG4gIFtUeXBlZC50eXBlTmFtZV0oKSB7XG4gICAgcmV0dXJuIGBVbmlvbigke3RoaXNbJHR5cGVdLm1hcCh0eXBlTmFtZSkuam9pbignLCAnKX0pYFxuICB9XG4gIFtUeXBlZC5yZWFkXSh2YWx1ZSkge1xuICAgIGNvbnN0IHZhcmlhbnRzID0gdGhpc1skdHlwZV1cbiAgICBjb25zdCBjb3VudCA9IHZhcmlhbnRzLmxlbmd0aFxuICAgIGxldCBpbmRleCA9IDBcbiAgICB3aGlsZSAoaW5kZXggPCBjb3VudCkge1xuICAgICAgY29uc3QgdmFyaWFudCA9IHZhcmlhbnRzW2luZGV4XVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdmFyaWFudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gaW5kZXggKyAxXG4gICAgfVxuXG4gICAgaW5kZXggPSAwXG4gICAgd2hpbGUgKGluZGV4IDwgY291bnQpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhcmlhbnRzW2luZGV4XVskcmVhZF0odmFsdWUpXG4gICAgICBpZiAoIShyZXN1bHQgaW5zdGFuY2VvZiBUeXBlRXJyb3IpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gaW5kZXggKyAxXG4gICAgfVxuXG4gICAgcmV0dXJuIFR5cGVFcnJvcihgXCIke3ZhbHVlfVwiIGRvZXMgbm90IHNhdGlzZnkgJHt0aGlzWyR0eXBlTmFtZV0oKX0gdHlwZWApXG4gIH1cbn1cblxuLy8gUmV0dXJucyBgeHNgIGV4Y2x1ZGluZyBhbnkgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGB5c2AuXG5jb25zdCBzdWJ0cmFjdCA9ICh4cywgeXMpID0+XG4gIHhzLmZpbHRlcih4ID0+IHlzLmluZGV4T2YoeCkgPCAwKVxuXG4vLyBSZXR1cm5zIGFycmF5IGluY2x1ZGluZyBhbGwgdmFsdWVzIGZyb20gYHhzYCBhbmQgYWxsIHZhbHVlcyBmcm9tXG4vLyBgeXNgIHRoYXQgYXJlbid0IGFscmVhZHkgaW5jbHVkZWQgaW4gYHhzYC4gSXQgd2lsbCBhbHNvIGF0dGVtcHRcbi8vIHRvIHJldHVybiBlaXRoZXIgYHhzYCBvciBgeXNgIGlmIG9uZSBvZiB0aGVtIGlzIGEgc3VwZXJzZXQgb2Ygb3RoZXIuXG4vLyByZXR1cm4gYHhzYCBvciBgeXNgIGlmXG5jb25zdCB1bmlvbiA9ICh4cywgeXMpID0+IHtcbiAgLy8geHMgY2FuIGJlIHN1cGVyc2V0IG9ubHkgaWYgaXQgY29udGFpbnMgbW9yZSBpdGVtcyB0aGVuXG4gIC8vIHlzLiBJZiB0aGF0J3MgYSBjYXNlIGZpbmQgaXRlbXMgaW4geXMgdGhhdCBhcmVudCBpbmNsdWRlZFxuICAvLyBpbiB4cy4gSWYgc3VjaCBpdGVtcyBkbyBub3QgZXhpc3QgcmV0dXJuIGJhY2sgYHhzYCBvdGhlcndpc2VcbiAgLy8gcmV0dXJuIGNvbmNhdGluYXRpb24gb2YgeHMgd2l0aCB0aG9zZSBpdGVtcy5cbiAgLy8gdGhvc2UgaXRlbXNcbiAgaWYgKHhzLmxlbmd0aCA+IHlzLmxlbmd0aCkge1xuICAgIGNvbnN0IGRpZmYgPSBzdWJ0cmFjdCh5cywgeHMpXG4gICAgcmV0dXJuIGRpZmYubGVuZ3RoID09PSAwID8geHMgOiB4cy5jb25jYXQoZGlmZilcbiAgfVxuICAvLyBpZiBudW1iZXIgb2YgaXRlbXMgaW4geHMgaXMgbm90IGdyZWF0ZXIgdGhhbiBudW1iZXIgb2YgaXRlbXMgaW4geXNcbiAgLy8gdGhlbiBlaXRoZXIgeHMgaXMgZWl0aGVyIHN1YnNldCBvciBlcXVhbCBvZiBgeXNgLiBUaGVyZSBmb3Igd2UgZmluZFxuICAvLyB5cyB0aGF0IGFyZSBub3QgaW5jbHVkZWQgaW4gYHhzYCBpZiBzdWNoIGl0ZW1zIGFyZW4ndCBmb3VuZCB5cyBpc1xuICAvLyBlaXRoZXIgc3VwZXJzZXQgb3IgZXF1YWwgc28ganVzdCByZXR1cm4geXMgb3RoZXJ3aXNlIHJldHVybiBjb25jYXRpbmF0aW9uXG4gIC8vIG9mIHRob3NlIGl0ZW1zIHdpdGggYHlzYC5cbiAgZWxzZSB7XG4gICAgY29uc3QgZGlmZiA9IHN1YnRyYWN0KHhzLCB5cylcbiAgICByZXR1cm4gZGlmZi5sZW5ndGggPT09IDAgPyB5cyA6IGRpZmYuY29uY2F0KHlzKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBVbmlvbiA9ICguLi5UeXBlcykgPT4ge1xuICBjb25zdCBjb3VudCA9IFR5cGVzLmxlbmd0aFxuXG4gIGlmIChjb3VudCA9PT0gMCkge1xuICAgIHRocm93IFR5cGVFcnJvcihgVW5pb24gbXVzdCBiZSBvZiBhdCBhdCBsZWFzdCBvbmUgdHlwZWApXG4gIH1cblxuICBsZXQgdmFyaWFudHMgPSBudWxsXG4gIGxldCB0eXBlID0gbnVsbFxuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBjb3VudCkge1xuICAgIGNvbnN0IHZhcmlhbnQgPSB0eXBlT2YoVHlwZXNbaW5kZXhdKVxuICAgIC8vIElmIHRoZXJlIGlzIGBBbnlgIHByZXNlbnQgdGhhbiB1bmlvbiBpcyBhbHNvIGBBbnlgLlxuICAgIGlmICh2YXJpYW50ID09PSBBbnkpIHtcbiAgICAgIHJldHVybiBBbnlcbiAgICB9XG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdHlwZSB3ZSBtZXQgdGhhbiB3ZSBhc3N1bWUgaXQncyB0aGVcbiAgICAvLyBvbmUgdGhhdCBzYXRpc2ZpZXMgYWxsIHR5cGVzLlxuICAgIGlmICghdmFyaWFudHMpIHtcbiAgICAgIHR5cGUgPSB2YXJpYW50XG4gICAgICB2YXJpYW50cyA9IHR5cGUgaW5zdGFuY2VvZiBVbmlvblR5cGUgPyB0eXBlWyR0eXBlXSA6IFt2YXJpYW50XVxuICAgIH0gZWxzZSBpZiAodmFyaWFudHMuaW5kZXhPZih2YXJpYW50KSA8IDApIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgcmVhZGVyIGlzIG9mIHVuaW9uIHR5cGVcbiAgICAgIGlmICh2YXJpYW50IGluc3RhbmNlb2YgVW5pb25UeXBlKSB7XG4gICAgICAgIGNvbnN0IHZhcmlhbnRVbmlvbiA9IHVuaW9uKHZhcmlhbnRzLCB2YXJpYW50WyR0eXBlXSlcblxuICAgICAgICAvLyBJZiBgcmVhZGVyLnJlYWRlcnNgIG1hdGNoZXMgdW5pb24gb2YgcmVhZGVycywgdGhlblxuICAgICAgICAvLyBjdXJyZW50IHJlYWRlciBpcyBhIHN1cGVyc2V0IHNvIHdlIHVzZSBpdCBhcyBhIHR5cGVcbiAgICAgICAgLy8gdGhhdCBzYXRpc2ZpZXMgYWxsIHR5cGVzLlxuICAgICAgICBpZiAodmFyaWFudFVuaW9uID09PSB2YXJpYW50WyR0eXBlXSkge1xuICAgICAgICAgIHR5cGUgPSB2YXJpYW50XG4gICAgICAgICAgdmFyaWFudHMgPSB2YXJpYW50VW5pb25cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBjdXJyZW50IHJlYWRlcnMgaXMgbm90IHRoZSB1bmlvbiB0aGFuIGl0IGRvZXMgbm90XG4gICAgICAgIC8vIHNhdGlzZnkgY3VycmVudHkgcmVhZGVyLiBUaGVyZSBmb3Igd2UgdXBkYXRlIHJlYWRlcnNcbiAgICAgICAgLy8gYW5kIHVuc2V0IGEgdHlwZS5cbiAgICAgICAgZWxzZSBpZiAodmFyaWFudFVuaW9uICE9PSB2YXJpYW50cykge1xuICAgICAgICAgIHR5cGUgPSBudWxsXG4gICAgICAgICAgdmFyaWFudHMgPSB2YXJpYW50VW5pb25cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IG51bGxcbiAgICAgICAgdmFyaWFudHMucHVzaCh2YXJpYW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gaW5kZXggKyAxXG4gIH1cblxuICByZXR1cm4gdHlwZSA/IHR5cGUgOiBuZXcgVW5pb25UeXBlKHZhcmlhbnRzKVxufVxuVW5pb24uVHlwZSA9IFVuaW9uVHlwZVxuXG5cblR5cGVkLk51bWJlci5SYW5nZSA9IChmcm9tLCB0bz0rSW5maW5pdHksIGRlZmF1bHRWYWx1ZSkgPT5cbiAgVHlwZWQoYFR5cGVkLk51bWJlci5SYW5nZSgke2Zyb219Li4ke3RvfSlgLCB2YWx1ZSA9PiB7XG4gICAgaWYgKHR5cGVvZih2YWx1ZSkgIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gVHlwZUVycm9yKGBcIiR7dmFsdWV9XCIgaXMgbm90IGEgbnVtYmVyYClcbiAgICB9XG5cbiAgICBpZiAoISh2YWx1ZSA+PSBmcm9tICYmIHZhbHVlIDw9IHRvKSkge1xuICAgICAgcmV0dXJuIFR5cGVFcnJvcihgXCIke3ZhbHVlfVwiIGlzbid0IGluIHRoZSByYW5nZSBvZiAke2Zyb219Li4ke3RvfWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH0sIGRlZmF1bHRWYWx1ZSlcbiJdfQ==