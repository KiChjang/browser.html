{
  "name": "typed-immutable",
  "version": "0.0.7",
  "description": "Immutable structurally typed data",
  "author": {
    "name": "Irakli Gozalishvili",
    "email": "rfobic@gmail.com",
    "url": "http://jeditoolkit.com"
  },
  "homepage": "https://github.com/gozala/typed-immutable",
  "keywords": [
    "record",
    "structure",
    "schema",
    "typed",
    "immutable",
    "data",
    "persistent",
    "datastructure",
    "functional"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/gozala/typed-immutable.git",
    "web": "https://github.com/Gozala/typed-immutable"
  },
  "bugs": {
    "url": "https://github.com/gozala/typed-immutable/issues"
  },
  "license": "MIT",
  "main": "./lib/index.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "tap lib/test/*.js",
    "start": "babel --watch --optional spec.protoToAssign --modules umdStrict --source-maps inline --out-dir ./lib ./src",
    "build": "babel --optional spec.protoToAssign --modules umdStrict --source-maps inline --out-dir ./lib ./src",
    "prepublish": "npm run build"
  },
  "dependencies": {
    "immutable": "3.7.0"
  },
  "devDependencies": {
    "babel": "5.6.14",
    "tap": "~0.4.8",
    "tape": "~2.3.2"
  },
  "readme": "# Typed-immutable [![NPM version][npm-image]][npm-url] [![Build Status][travis-image]][travis-url] [![Gitter][gitter-image]][gitter-url]\n=========\n\nLibrary provides is built upon [immutable.js][] to leverage it’s immutable [persistent][] data and provide structural typing on top of that. Library is not aiming to provide type safety of typed language (some static type checker like [flow][] would be tool for that) although it allows user to define structured types and guarantees that values produced and later transformed will conform to pre-defined structure. Handy use case for such tool would be an application state modelling (in [MVC][] sense), specially if state is centralised but compartmentalized for us by independent components.\n\n\n## API\n\nIn the following sections we would use term \"type\" for a javascript class that can be instantiated via function call (although use of `new` still possible) and produces immutable persistent data structure that we’ll refer to as \"value\" as they will have more common with primitive values like strings or numbers than with objects.\n\n### Record\n\nRecords are a labeled data structure. They provide a lightweight representation for complex data. Record types can be defined by invoking `Record` function with a type structure descriptor, that is an object that provides field names and types associated with them:\n\n```js\nvar {Record} = require(\"typed-immutable\")\n\nvar Point = Record({x: Number, y: Number})\n```\n\nRecord types maybe invoked as functions or instantiated as a class to produce a value in form of immutable object with a pre-defined structure:\n\n```js\nPoint({x:0, y:0}) // => {x:0, y:0}\nnew Point({x: 0, y:0}) // => {x:0, y:0}\n```\n\nRecord types enforce pre-defined structure and will fail if input provided does not match it:\n\n```js\nPoint() // => TypeError: Invalid value for \"x\" field:\n        //               \"undefined\" is not a number\n\n\nPoint({x: \"1\", y: \"2\"}) // => TypeError: Invalid value for \"x\" field:\n                        //     \"1\" is not a number\n```\n\n\nRecord types definitions may also be provided a default values for feilds for a convinence of use:\n\n```js\nvar Point = Record({x: Number(0), y: Number(0)})\nPoint() // => { \"x\": 0, \"y\": 0 }\nPoint({x: 20}) // => { \"x\": 20, \"y\": 0 }\n\nPoint({x: null}) // => TypeError: Invalid value for \"x\" field:\n                 //     \"null\" is not a number\n```\n\nRecord fields can be accessed by name via property access syntax:\n\n```js\nvar p1 = Point({x: 17})\np1.x // => 17\np1.y // => 0\n```\n\nAttempts to update a field will fail with error:\n\n```js\np1.x = 30 // =>  TypeError: Cannot set on an immutable record.\n```\n\nInstead of changing a record values you can transform them or create new values from existing one similar to how you do that with strings or numbers:\n\n```js\np1 = Point() // => {x:0, y:0}\np1.set(\"x\", 7) // => {x: 7, y:0}\np1 // => {x:0, y:0}\n```\n\nRemoveing a field from a record simply resets it's value to the default if one was defined.\n\n```js\nvar p1 = Point({x: 1, y: 25}) // => {x:1, y:25}\np1.remove(\"y\") // => {x:1, y:0}\n```\n\nRecord types proudce values with only fields that they were defined with everything else\nthey simply ignore:\n\n```js\nPoint({x:30, y:40, z:8}) // => {x:30, y:40}\n```\n\nAlthough the do explicitly forbid setting undeclared fields with error:\n\n```js\nPoint().set(\"z\", 5) // => TypeError: Cannot set unknown field \"z\" on \"Typed.Record({x: Number(0), y: Number(0)})\"\n```\n\nRecord values are actually instances of the record type / class but given immutablity they have much more common with values which is why we refer to them as such:\n\n```js\nvar p1 = Point()\np1 instanceof Point // true\np1.x // => 0\np1.y // => 0\n\nvar p2 = p1.merge({x: 23})\np2 instanceof Point // true\np2.x // => 23\np2.y // => 0\n\np1.equals(Point()) // => true\n\np1.equals(p2) // => false\n\np2.equals(Point({x: 23})) // => true\n```\n\nRecord values serialize to strings that containing their value and a type signature\n\n```js\nPoint({x:23}).toString() // => ‘Typed.Record({x: Number(0), y: Number(0)})({ \"x\": 23, \"y\": 0 })’\n```\n\nBut for records with large number of fields it maybe more handy to provide a name, that\ncan be done during definition:\n\n```js\nvar Point = Record({x: Number(0), y: Number(0)}, \"Point\")\n\nPoint({x: 4, y: 7}).toString() // => ‘Point({ \"x\": 4, \"y\": 7 })’\n```\n\n##### Nested records\n\nFor any complex data defining records contaning records is crucial, which works exactly as expected:\n\n```js\nvar Line = Record({begin: Point, end: Point}, \"Line\")\nvar line = Line({end: {x: 70}})\n\nline instanceof Line // => true\n\nline.toString() // => Line({ \"begin\": Point({ \"x\": 0, \"y\": 0 }), \"end\": Point({ \"x\": 70, \"y\": 0 }) })\n\nline.begin // => {x: 0, y:0}\nline.begin instanceof Point // => true\n\nline.end // => {x: 70, y:0}\nline.end instanceof Point // => true\n```\n\nAs with primitive fields you could provide defaults to a complex records as well:\n\n```js\nvar Line = Record({begin: Point({x:23}), end: Point({y:4})}, \"Line\")\nLine().toString() //=> Line({ \"begin\": Point({ \"x\": 23, \"y\": 0 }), \"end\": Point({ \"x\": 0, \"y\": 4 }) })\n```\n\nRecords can be serialized to JSON and then instantiated back to an equal record value:\n\n```js\nLine(line.toJSON()).equals(line) // => true\n```\n\n### List\n\nYou can define typed lists by providing a `List` function a type that it’s\nitems are supposed to be of:\n\n```js\nvar {List} = require(\"typed-immutable\")\n\nvar Numbers = List(Number)\n\nNumbers().toString() // ‘Typed.List(Number)([])’\n\nNumbers.of(1, 2, 3).toString() // => ‘Typed.List(Number)([ 1, 2, 3 ])’\n```\n\nTyped lists may contain only items of that type and fail with error if attempted to do otherwise:\n\n```js\nNumbers([2, 3]).toString() // => Typed.List(Number)([ 2, 3 ])\n\nNumbers([1, 2, 3, \"4\", \"5\"]) // => TypeError: Invalid value: \"4\" is not a number\n\nNumbers([1, 2, 3]).push(null) // => TypeError: Invalid value: \"null\" is not a number\n```\n\nTyped lists can also be named for convinience:\n\n```js\nvar Strings = List(String, \"Strings\")\n\nStrings.of(\"hello\", \"world\").toString() // => Strings([ \"hello\", \"world\" ])\n```\n\nList can be of a complex a specific record type & records can also have fields of typed list:\n\n\n```js\nvar Points = List(Point, \"Points\")\nPoints().toString() // => Points([])\n\nps = Points.of({x:3}, {y: 5}).toString()\nps.toString() // => Points([ Point({ \"x\": 3, \"y\": 0 }), Point({ \"x\": 0, \"y\": 5 }) ])'\n\nps.get(0) instanceof Point // => true\nps.get(1) instanceof Point // => true\n\nps.get(0).x // => 3\nps.get(1).y // => 5\n\nps.push({z:4, x:-4}).toJSON() // => [ { x: 3, y: 0 }, { x: 0, y: 5 }, { x: -4, y: 0 } ]\n\nPoints(ps.toJSON()).equals(ps) // => true\n```\n\n##### mapping lists form one type to other\n\nOne somewhat tricky thing about lists is that while they enforce certain type they can also be as easily converted to list of other type by simply mapping it:\n\n```js\nps = Points.of({x:1}, {x:2})\nxs = ps.map(p => p.x)\n\nps.toString() // => Points([ Point({ \"x\": 1, \"y\": 0 }), Point({ \"x\": 2, \"y\": 0 }) ])\nxs.toString() // => Typed.List(Number)([ 1, 2 ])\n```\n\nAs you can see from example above original `ps` list was of `Point` records while mapped `xs` list is of numbers and that is refleced in the type of the list. Although given that JS is untyped language theer is no guarantee that mapping function will return values of the same type which makes things little more complex, result of such mapping will be list of union type of all types that mapping funciton produced (see types section for union types).\n\n\n### Types\n\nAs it was illustrated in above sections we strucutre our types using other types there for this libary supports most JS types out of the box and provides few extra to cover more complex cases.\n\n#### JS native types\n\nYou can use `Boolean` `Number` `String` `RegExp` JS built-in constructs structures of those types.\n\n#### Maybe\n\nYou can define an optional type using `Maybe` that will produce a type whos value can be `undefined` `null` or a value of the provided type:\n\n```js\nvar {Maybe} = require(\"typed-immutable\")\nvar Color = Record({\n  red: Number(0),\n  green: Number(0),\n  blue: Number(0),\n  opacity: Maybe(Number)\n})\n\nColor().toJSON() // => { red: 0, green: 0, blue: 0, opacity: null }\nColor({red: 200, opacity: 80}).toJSON() // => { red: 200, green: 0, blue: 0, alpha: 80 }\nColor({red: 200, opacity: \"transparent\"}) // => TypeError: Invalid value for \"opacity\" field:\n                                          // \"transparent\" is not nully nor it is of Number type\n```\n\n#### Union\n\nA union type is a way to put together many different types. This lets you create list or records fields that can take  either one of the several types:\n\n```js\nvar {Maybe} = require(\"typed-immutable\")\nvar Form = Record({\n  user: Union(Username, Email),\n  password: String('')\n})\n\nvar form = Form()\nform.set('user', Username('gozala'))\nform.set('user', Email('gozala@mail.com'))\n```\n\n#### Custom Type\n\nLibrary lets you declare your own custom types that then you can use in defining more complex types with records and lists:\n\n```js\nvar {Typed} = require(\"typed-immutable\")\nvar Range = (from, to=+Infinity) =>\n  Typed(`Typed.Number.Range(${from}..${to})`, value => {\n    if (typeof(value) !== 'number') {\n      return TypeError(`\"${value}\" is not a number`)\n    }\n\n    if (!(value >= from && value <= to)) {\n      return TypeError(`\"${value}\" isn't in the range of ${from}..${to}`)\n    }\n\n    return value\n  })\n\nvar Color = Record({\n  red: Range(0, 255),\n  green: Range(0, 255),\n  blue: Range(0, 255)\n})\n\nColor({red: 20, green: 20, blue: 20}).toJSON() // => { red: 20, green: 20, blue: 20 }\nColor({red: 20, green: 20, blue: 300}) // => TypeError: Invalid value for \"blue\" field:\n                                       // \"300\" isn't in the range of 0..255\n\nColor() // => TypeError: Invalid value for \"red\" field:\n        // \"undefined\" is not a number\n\nvar Color = Record({\n  red: Range(0, 255)(0),\n  green: Range(0, 255)(0),\n  blue: Range(0, 255)(0)\n})\n\nColor().toJSON() // => { red: 0, green: 0, blue: 0 }\n```\n\nAs a matter of fact `Typed` contains bunch of other types including `Typed.Number.Range` similar to one from the example above.\n\n#### Any type\n\nWhile this defeats the whole purpose there are still cases where use of `Any` type may be a good short term solution. In addition as described in the section about list mapping lists could be mapped to arbitrary types and there are cases where result of mapping is `List(Any)`:\n\n```js\nvar {Any} = require(\"typed-immutable\")\nvar Box = Record({value: Any})\n\nvar v1 = Box({value: 5})\nvar v2 = v1.set(\"value\", \"hello\")\nvar v3 = v2.set(\"value\", v2)\n\nv1.toString() // => Typed.Record({value: Any})({ \"value\": 5 })\nv2.toString() // => Typed.Record({value: Any})({ \"value\": \"hello\" })\nv3.toString() // => Typed.Record({value: Any})({ \"value\": Typed.Record({value: Any})({ \"value\": \"hello\" }) })\n```\n\n\n## License\n\n[MIT License](http://en.wikipedia.org/wiki/MIT_License)\n\n[npm-url]: https://npmjs.org/package/typed-immutable\n[npm-image]: https://img.shields.io/npm/v/typed-immutable.svg?style=flat\n\n[travis-url]: https://travis-ci.org/Gozala/typed-immutable\n[travis-image]: https://img.shields.io/travis/Gozala/typed-immutable.svg?style=flat\n\n[gitter-url]: https://gitter.im/Gozala/typed-immutable?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\n[gitter-image]: https://badges.gitter.im/Join%20Chat.svg\n\n\n\n[immutable.js]:http://facebook.github.io/immutable-js/\n[Persistent]:http://en.wikipedia.org/wiki/Persistent_data_structure\n[MVC]:http://en.wikipedia.org/wiki/Model–view–controller\n[structs]:http://en.wikipedia.org/wiki/Struct_(C_programming_language)\n[flow]:http://flowtype.org\n",
  "readmeFilename": "Readme.md",
  "_id": "typed-immutable@0.0.7",
  "_shasum": "6cac913486d48153e61c7db5370caa87587b6774",
  "_resolved": "https://registry.npmjs.org/typed-immutable/-/typed-immutable-0.0.7.tgz",
  "_from": "https://registry.npmjs.org/typed-immutable/-/typed-immutable-0.0.7.tgz"
}
