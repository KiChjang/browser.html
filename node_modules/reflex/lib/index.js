(function (global, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['exports', 'react'], factory);
  } else if (typeof exports !== 'undefined') {
    factory(exports, require('react'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.React);
    global.index = mod.exports;
  }
})(this, function (exports, _react) {
  'use strict';

  var _get = function get(_x5, _x6, _x7) { var _again = true; _function: while (_again) { var object = _x5, property = _x6, receiver = _x7; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x5 = parent; _x6 = property; _x7 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

  var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

  function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

  function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) _defaults(subClass, superClass); }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

  if (typeof Symbol === 'undefined') {
    var Symbol = function Symbol(name) {
      return '@@' + name + '#' + Math.random().toString(36).substr(2);
    };
    Symbol['for'] = function (name) {
      return '@@' + name;
    };
  }

  if (typeof WeakMap === 'undefined') {
    var WeakMap;

    (function () {
      var weakMapID = 0;

      WeakMap = (function () {
        var _class = function WeakMap() {
          _classCallCheck(this, _class);

          this.id = 'weak#' + (++weakMapID).toString(36);
        };

        _createClass(_class, [{
          key: 'has',
          value: function has(key) {
            return this.hasOwnProperty.call(key, this.id);
          }
        }, {
          key: 'set',
          value: function set(key, value) {
            key[this.id] = value;
          }
        }, {
          key: 'get',
          value: function get(key) {
            return key[this.id];
          }
        }, {
          key: 'delete',
          value: function _delete(key) {
            delete key[this.id];
          }
        }, {
          key: 'clear',
          value: function clear() {
            this.constructor();
            console.warn('WeakMap polyfill does not release references');
          }
        }]);

        return _class;
      })();
    })();
  }

  // node function constructs a virtual dom nodes. It takes node `tagName`,
  // optional `model` properties and optional `children` and produces instance
  // of the appropriate virtual `Node`.
  var node = function node(tagName, model) {
    var children = arguments[2] === undefined ? NodeList.empty : arguments[2];

    var properties = {};

    if (model) {
      for (var _name in model) {
        if (model.hasOwnProperty(_name)) {
          var value = model[_name];
          if (_name === 'style' && value && value.toJSON) {
            properties[_name] = value.toJSON();
          } else {
            properties[_name] = value;
          }
        }
      }
    }

    properties.children = children;

    return _react.createElement(tagName, properties);
  };

  exports.node = node;
  // Create a function for react supported nodes.
  var html = Object.create(null);
  exports.html = html;
  Object.keys(_react.DOM).forEach(function (tagName) {
    html[tagName] = function (model, children) {
      return node(tagName, model, children);
    };
  });

  // Fragment insntances represents a namespacing facility for
  // entities in virtual dom tree, primarily to group several keyed
  // nodes without wrapping them in an element. This allows different
  // groups of nodes to be joined under the same parent. Namespacing
  // such groups with a `properties.key` is crucial for optimising
  // performance of virtual dom diffing algorithm. Optionally
  // `properties.type` can be passed that will be a tagName of node
  // if fragment is rendered as a root of dom tree, or root of the
  // subtree that is computed lazily by a thunk. `children` argument
  // is an array of nodes that this fragment represents.

  var Fragment = function Fragment(properties, children) {
    _classCallCheck(this, Fragment);

    this.key = properties.key;
    this.type = properties.type || 'x:fragment';
    this.properties = properties;
    this.children = children;

    this._reactFragment = _defineProperty({}, this.key, this.children);
  };

  // Function for constructing fragments of virtual dom tree.
  // Takes `properties.key` for identifying fragment, optional
  // `properties.type` which is used as wrapper node for given
  // `children` if fragment is returned from thunk or is rendered
  // directly.
  var fragment = function fragment(properties, children) {
    return new Fragment(properties, children);
  };

  exports.fragment = fragment;

  var Forwarder = (function () {
    function Forwarder(addressBook, to) {
      _classCallCheck(this, Forwarder);

      this.addressBook = addressBook;
      this.to = to;
    }

    _createClass(Forwarder, [{
      key: 'receive',
      value: function receive(action) {
        this.addressBook[this.to].receive(action);
      }
    }]);

    return Forwarder;
  })();

  // Thunk instances are entities in a virtual dom tree that represent
  // lazily compute sub-trees with built-in caching that avoid re-computing
  // sub-tree when same data is being rendered.

  var Thunk = (function (_React$Component) {
    function Thunk(props, context) {
      _classCallCheck(this, Thunk);

      _get(Object.getPrototypeOf(Thunk.prototype), 'constructor', this).call(this, props, context);
    }

    _inherits(Thunk, _React$Component);

    _createClass(Thunk, [{
      key: 'componentWillMount',
      value: function componentWillMount() {
        var args = this.props.args;

        var count = args.length;

        var addressBook = new Array(count);
        var params = new Array(count);

        var index = 0;
        while (index < count) {
          var arg = args[index];
          if (arg instanceof Address) {
            addressBook[index] = arg;
            params[index] = new Address(new Forwarder(addressBook, index));
          } else {
            params[index] = arg;
          }
          index = index + 1;
        }

        this.setState({ args: params, addressBook: addressBook });
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(_ref) {
        var after = _ref.args;

        if (profile) {
          console.time(this.props.Key + '.compute');
        }

        var _state = this.state;
        var args = _state.args;
        var addressBook = _state.addressBook;

        var count = after.length;
        var index = 0;
        var isUpdated = false;

        if (args.length !== count) {
          isUpdated = true;
          args.length = count;
          addressBook.length = count;
        }

        while (index < count) {
          var next = after[index];
          var arg = args[index];

          if (next === arg) {} else if (next instanceof Address && arg instanceof Address) {
            // Update adrress book with a new address.
            addressBook[index] = next;
          } else {
            isUpdated = true;

            if (next instanceof Address) {
              addressBook[index] = next;
              args[index] = new Address(this, [redirect(index)]);
            } else {
              args[index] = next;
            }
          }
          index = index + 1;
        }

        if (isUpdated) {
          this.setState({ args: args, addressBook: addressBook });
        }

        if (profile) {
          console.timeEnd(this.props.Key + '.compute');
        }
      }
    }, {
      key: 'shouldComponentUpdate',
      value: function shouldComponentUpdate(_, state) {
        return state !== this.state;
      }
    }, {
      key: 'render',
      value: function render() {
        if (profile) {
          console.time(this.props.Key + '.render');
        }

        // Store currently operating view to enable cacheing by
        // the view.
        Thunk.context = this.view;

        var args = this.state.args;

        var result = this.view.apply(this, _toConsumableArray(args));

        Thunk.context = null;

        if (profile) {
          console.timeEnd(this.props.Key + '.render');
        }
        return result;
      }
    }], [{
      key: 'for',
      value: function _for(view, key) {
        var ReactComponent = (function (_Thunk) {
          function ReactComponent(props, context) {
            _classCallCheck(this, ReactComponent);

            _get(Object.getPrototypeOf(ReactComponent.prototype), 'constructor', this).call(this, props, context);
            this.view = view;
          }

          _inherits(ReactComponent, _Thunk);

          return ReactComponent;
        })(Thunk);

        ReactComponent.displayName = key.split('@')[0];
        return ReactComponent;
      }
    }]);

    return Thunk;
  })(_react.Component);

  var contextualCache = new WeakMap();
  var contextlessCache = new WeakMap();

  var cache = function cache(f) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var cache = null;
    var changed = false;
    var context = Thunk.context;

    if (context) {
      cache = contextualCache.get(f);
      if (!cache) {
        contextualCache.set(f, cache = new WeakMap());
      }
    } else {
      cache = contextlessCache;
    }

    var memory = cache.get(f);
    if (memory) {
      var input = memory.input;

      var count = input.length;
      var index = 0;
      var _changed = args.length !== count;
      while (!_changed && index < count && !_changed) {
        var past = input[index];
        var current = args[index];

        _changed = current !== past;
        index = index + 1;
      }

      if (_changed) {
        memory.output = f.apply(undefined, args);
        memory.input = args;
      }
    } else {
      memory = { output: f.apply(undefined, args), input: args };
      cache.set(f, memory);
    }

    return memory.output;
  };

  exports.cache = cache;
  // render function provides shortcut for rendering a model with
  // default view function (although custom view function can be
  // passed as second optional argument), but unlike calling view
  // directly result is a thunk, there for it's defers actual computation
  // and makes use of caching to avoid computation when possible.
  var render = function render(key, view) {
    for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }

    var component = view.reactComponent || (view.reactComponent = Thunk['for'](view, key));
    return _react.createElement(component, { key: key, Key: key, args: args });
  };

  exports.render = render;
  var GUID = 0;

  var ParameterizedReceiver = function ParameterizedReceiver(address, read, prefix) {
    return function (event) {
      return address.receive(read.apply(undefined, _toConsumableArray(prefix).concat([event])));
    };
  };

  var Receiver = function Receiver(address, read) {
    return function (event) {
      return address.receive(read(event));
    };
  };

  var Address = (function () {
    function Address(mailbox, forwarders) {
      _classCallCheck(this, Address);

      this.id = ++GUID;
      this.mailbox = mailbox;
      this.forwarders = forwarders;
    }

    _createClass(Address, [{
      key: 'forward',
      value: function forward(anotate) {
        var cache = anotate[Address.cache] || (anotate[Address.cache] = {});

        if (!cache[this.id]) {
          var forwarders = this.forwarders ? [anotate].concat(this.forwarders) : [anotate];
          cache[this.id] = new Address(this.mailbox, forwarders);
        }

        return cache[this.id];
      }
    }, {
      key: 'receive',
      value: function receive(action) {
        if (this.isBlocked && action !== null) {
          (this.queue || (this.queue = [])).push(action);
        } else {
          var forwarders = this.forwarders;

          this.isBlocked = true;
          var ticket = -1;

          // Define a `delivered` flag that is updated at the begining of action
          // delivery and at the end of it. This is so that in finally we can
          // figure out if exception was throw or not.
          var delivered = false;

          while (this.isBlocked) {
            try {
              delivered = false;

              if (action !== null) {
                if (forwarders) {
                  var count = forwarders.length;
                  var index = 0;
                  while (index < count) {
                    action = forwarders[index](action);
                    index = index + 1;
                  }
                }

                this.mailbox.receive(action);

                delivered = true;
              }
            } finally {
              ticket = ticket + 1;
              this.isBlocked = this.queue && this.queue.length > ticket;
              action = this.isBlocked && this.queue[ticket];

              // If failed to deliver (exception was thrown) and address is still
              // blocked that means there are still pending actions to process. In
              // that case we unblock an address remove delivered actions from a
              // queue and re-enter receive loop. This way receive drains action
              // action loop regardless of exceptions that may occur.
              if (!delivered && this.isBlocked) {
                this.isBlocked = false;
                this.queue && this.queue.splice(0, ticket + 1);
                this.receive(action);
              }
            }
          }

          this.queue && this.queue.splice(0);
        }
      }
    }, {
      key: 'send',
      value: function send(action) {
        var _this = this;

        return function (_) {
          return _this.receive(action);
        };
      }
    }, {
      key: 'pass',
      value: function pass(read) {
        if (typeof read !== 'function') {
          throw TypeError('Non function was passed to address.pass');
        }

        for (var _len3 = arguments.length, prefix = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          prefix[_key3 - 1] = arguments[_key3];
        }

        return prefix.length ? ParameterizedReceiver(this, read, prefix) : read['reflex/address-' + this.id] || (read['reflex/address-' + this.id] = Receiver(this, read));
      }
    }]);

    return Address;
  })();

  exports.Address = Address;

  Address.cache = Symbol['for']('reflex/address-book');

  // Program is a root entity of the virtual dom tree that is responsible
  // for computing a virtual dom tree for the `state` via given `view` function
  // and reacting to dispatched actions via given `update` by updating a state
  // and restarting a the same cycle again.

  var Application = (function () {
    function Application(_ref2) {
      var address = _ref2.address;
      var target = _ref2.target;
      var state = _ref2.state;
      var update = _ref2.update;
      var view = _ref2.view;

      _classCallCheck(this, Application);

      this.target = target;
      this.view = view;
      this.update = update;
      this.state = state;
      this.address = address;
      this.render = this.render.bind(this);
    }

    _createClass(Application, [{
      key: 'receive',
      value: function receive(action) {
        this.action = action;
        var state = this.update(this.state, this.action);
        if (state !== this.state) {
          this.state = state;
          this.schedule();
        }
      }
    }, {
      key: 'schedule',
      value: function schedule() {
        if (!this.isScheduled) {
          this.isScheduled = true;
          this.version = requestAnimationFrame(this.render);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        if (profile) {
          console.time('React.render');
        }

        var start = performance.now();

        // It is important to mark `isScheduled` as `false` before doing actual
        // rendering since state changes in effect of reflecting current state
        // won't be handled by this render cycle. For example rendering a state
        // with updated focus will cause `blur` & `focus` events to be dispatched
        // that happen synchronously, and there for another render cycle may be
        // scheduled for which `isScheduled` must be `false`. Attempt to render
        // this state may also cause a runtime exception but even then we would
        // rather attempt to render updated states that end up being blocked
        // forever.
        this.isScheduled = false;
        if (profile) {
          console.time('Application.render');
        }

        this.tree = this.view(this.state, this.address);

        if (profile) {
          console.timeEnd('Application.render');
        }

        if (profile) {
          console.time('React.reconcile');
        }

        _react.render(this.tree, this.target);

        if (profile) {
          console.timeEnd('React.reconcile');
        }

        var end = performance.now();
        var time = end - start;

        if (time > 16) {
          console.warn('Render took ' + time + 'ms & will cause frame drop');
        }

        if (profile) {
          console.timeEnd('React.render');
        }
        return this;
      }
    }]);

    return Application;
  })();

  exports.Application = Application;

  // Function that takes `target` element to continiusly render given `model`
  // into. model's default `update` function is used to update module in response
  // to dispatched actions and model's default `view` function is used to compute
  // dom tree represantation of the model. Optionally custom `update` and `view`
  // functions could be passed to customize render loop.
  var main = function main(target, model) {
    var update = arguments[2] === undefined ? model.constructor.update : arguments[2];
    var view = arguments[3] === undefined ? model.constructor.view : arguments[3];
    return (function () {
      var application = new Application({
        state: model,
        target: target, update: update, view: view
      });
      application.address = new Address(application);

      application.schedule();
      return application;
    })();
  };

  exports.main = main;
  var profile = null;
  var time = function time() {
    var name = arguments[0] === undefined ? '' : arguments[0];
    return profile = name + ' ';
  };
  exports.time = time;
  var timeEnd = function timeEnd() {
    return profile = null;
  };
  exports.timeEnd = timeEnd;
});

// do nothing
//# sourceMappingURL=data:application/json;base64,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QUFXLENBQUMsTUFBTTtRQUFFLElBQUksZ0NBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJO3dCQUFLO0FBQ2pHLFVBQU0sV0FBVyxHQUFHLElBQUksV0FBVyxDQUFDO0FBQ2xDLGFBQUssRUFBRSxLQUFLO0FBQ1osY0FBTSxFQUFOLE1BQU0sRUFBRSxNQUFNLEVBQU4sTUFBTSxFQUFFLElBQUksRUFBSixJQUFJO09BQ3JCLENBQUMsQ0FBQTtBQUNGLGlCQUFXLENBQUMsT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDOztBQUUvQyxpQkFBVyxDQUFDLFFBQVEsRUFBRSxDQUFBO0FBQ3RCLGFBQU8sV0FBVyxDQUFBO0tBQ25CO0dBQUEsQ0FBQTs7VUFUVSxJQUFJLEdBQUosSUFBSTtBQVdmLE1BQUksT0FBTyxHQUFHLElBQUksQ0FBQTtBQUNYLE1BQU0sSUFBSSxHQUFHLFNBQVAsSUFBSTtRQUFJLElBQUksZ0NBQUMsRUFBRTtXQUMxQixPQUFPLEdBQU0sSUFBSSxNQUFHO0dBQUEsQ0FBQTtVQURULElBQUksR0FBSixJQUFJO0FBRVYsTUFBTSxPQUFPLEdBQUcsU0FBVixPQUFPO1dBQ2xCLE9BQU8sR0FBRyxJQUFJO0dBQUEsQ0FBQTtVQURILE9BQU8sR0FBUCxPQUFPIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCJcblxuaWYgKHR5cGVvZihTeW1ib2wpID09PSAndW5kZWZpbmVkJykge1xuICB2YXIgU3ltYm9sID0gbmFtZSA9PiBgQEAke25hbWV9IyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIpfWBcbiAgU3ltYm9sLmZvciA9IG5hbWUgPT4gYEBAJHtuYW1lfWBcbn1cblxuXG5pZiAodHlwZW9mKFdlYWtNYXApID09PSAndW5kZWZpbmVkJykge1xuICBsZXQgd2Vha01hcElEID0gMDtcbiAgdmFyIFdlYWtNYXAgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLmlkID0gYHdlYWsjJHsoKyt3ZWFrTWFwSUQpLnRvU3RyaW5nKDM2KX1gXG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc093blByb3BlcnR5LmNhbGwoa2V5LCB0aGlzLmlkKTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGtleVt0aGlzLmlkXSA9IHZhbHVlXG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBrZXlbdGhpcy5pZF1cbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgZGVsZXRlIGtleVt0aGlzLmlkXVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IoKVxuICAgICAgY29uc29sZS53YXJuKCdXZWFrTWFwIHBvbHlmaWxsIGRvZXMgbm90IHJlbGVhc2UgcmVmZXJlbmNlcycpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vZGUgZnVuY3Rpb24gY29uc3RydWN0cyBhIHZpcnR1YWwgZG9tIG5vZGVzLiBJdCB0YWtlcyBub2RlIGB0YWdOYW1lYCxcbi8vIG9wdGlvbmFsIGBtb2RlbGAgcHJvcGVydGllcyBhbmQgb3B0aW9uYWwgYGNoaWxkcmVuYCBhbmQgcHJvZHVjZXMgaW5zdGFuY2Vcbi8vIG9mIHRoZSBhcHByb3ByaWF0ZSB2aXJ0dWFsIGBOb2RlYC5cbmV4cG9ydCBsZXQgbm9kZSA9ICh0YWdOYW1lLCBtb2RlbCwgY2hpbGRyZW49Tm9kZUxpc3QuZW1wdHkpID0+IHtcbiAgbGV0IHByb3BlcnRpZXMgPSB7fVxuXG4gIGlmIChtb2RlbCkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gbW9kZWwpIHtcbiAgICAgIGlmIChtb2RlbC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG1vZGVsW25hbWVdXG4gICAgICAgIGlmIChuYW1lID09PSBcInN0eWxlXCIgJiYgdmFsdWUgJiYgdmFsdWUudG9KU09OKSB7XG4gICAgICAgICAgcHJvcGVydGllc1tuYW1lXSA9IHZhbHVlLnRvSlNPTigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcGVydGllc1tuYW1lXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm9wZXJ0aWVzLmNoaWxkcmVuID0gY2hpbGRyZW5cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBwcm9wZXJ0aWVzKVxufVxuXG5cbi8vIENyZWF0ZSBhIGZ1bmN0aW9uIGZvciByZWFjdCBzdXBwb3J0ZWQgbm9kZXMuXG5leHBvcnQgbGV0IGh0bWwgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5PYmplY3Qua2V5cyhSZWFjdC5ET00pLmZvckVhY2godGFnTmFtZSA9PiB7XG4gIGh0bWxbdGFnTmFtZV0gPSAobW9kZWwsIGNoaWxkcmVuKSA9PiBub2RlKHRhZ05hbWUsIG1vZGVsLCBjaGlsZHJlbilcbn0pXG5cblxuLy8gRnJhZ21lbnQgaW5zbnRhbmNlcyByZXByZXNlbnRzIGEgbmFtZXNwYWNpbmcgZmFjaWxpdHkgZm9yXG4vLyBlbnRpdGllcyBpbiB2aXJ0dWFsIGRvbSB0cmVlLCBwcmltYXJpbHkgdG8gZ3JvdXAgc2V2ZXJhbCBrZXllZFxuLy8gbm9kZXMgd2l0aG91dCB3cmFwcGluZyB0aGVtIGluIGFuIGVsZW1lbnQuIFRoaXMgYWxsb3dzIGRpZmZlcmVudFxuLy8gZ3JvdXBzIG9mIG5vZGVzIHRvIGJlIGpvaW5lZCB1bmRlciB0aGUgc2FtZSBwYXJlbnQuIE5hbWVzcGFjaW5nXG4vLyBzdWNoIGdyb3VwcyB3aXRoIGEgYHByb3BlcnRpZXMua2V5YCBpcyBjcnVjaWFsIGZvciBvcHRpbWlzaW5nXG4vLyBwZXJmb3JtYW5jZSBvZiB2aXJ0dWFsIGRvbSBkaWZmaW5nIGFsZ29yaXRobS4gT3B0aW9uYWxseVxuLy8gYHByb3BlcnRpZXMudHlwZWAgY2FuIGJlIHBhc3NlZCB0aGF0IHdpbGwgYmUgYSB0YWdOYW1lIG9mIG5vZGVcbi8vIGlmIGZyYWdtZW50IGlzIHJlbmRlcmVkIGFzIGEgcm9vdCBvZiBkb20gdHJlZSwgb3Igcm9vdCBvZiB0aGVcbi8vIHN1YnRyZWUgdGhhdCBpcyBjb21wdXRlZCBsYXppbHkgYnkgYSB0aHVuay4gYGNoaWxkcmVuYCBhcmd1bWVudFxuLy8gaXMgYW4gYXJyYXkgb2Ygbm9kZXMgdGhhdCB0aGlzIGZyYWdtZW50IHJlcHJlc2VudHMuXG5jbGFzcyBGcmFnbWVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMsIGNoaWxkcmVuKSB7XG4gICAgdGhpcy5rZXkgPSBwcm9wZXJ0aWVzLmtleTtcbiAgICB0aGlzLnR5cGUgPSBwcm9wZXJ0aWVzLnR5cGUgfHwgJ3g6ZnJhZ21lbnQnO1xuICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgdGhpcy5fcmVhY3RGcmFnbWVudCA9IHtbdGhpcy5rZXldOiB0aGlzLmNoaWxkcmVufVxuICB9XG59XG5cbi8vIEZ1bmN0aW9uIGZvciBjb25zdHJ1Y3RpbmcgZnJhZ21lbnRzIG9mIHZpcnR1YWwgZG9tIHRyZWUuXG4vLyBUYWtlcyBgcHJvcGVydGllcy5rZXlgIGZvciBpZGVudGlmeWluZyBmcmFnbWVudCwgb3B0aW9uYWxcbi8vIGBwcm9wZXJ0aWVzLnR5cGVgIHdoaWNoIGlzIHVzZWQgYXMgd3JhcHBlciBub2RlIGZvciBnaXZlblxuLy8gYGNoaWxkcmVuYCBpZiBmcmFnbWVudCBpcyByZXR1cm5lZCBmcm9tIHRodW5rIG9yIGlzIHJlbmRlcmVkXG4vLyBkaXJlY3RseS5cbmV4cG9ydCBsZXQgZnJhZ21lbnQgPSAocHJvcGVydGllcywgY2hpbGRyZW4pID0+XG4gIG5ldyBGcmFnbWVudChwcm9wZXJ0aWVzLCBjaGlsZHJlbilcblxuY2xhc3MgRm9yd2FyZGVyIHtcbiAgY29uc3RydWN0b3IoYWRkcmVzc0Jvb2ssIHRvKSB7XG4gICAgdGhpcy5hZGRyZXNzQm9vayA9IGFkZHJlc3NCb29rXG4gICAgdGhpcy50byA9IHRvXG4gIH1cbiAgcmVjZWl2ZShhY3Rpb24pIHtcbiAgICB0aGlzLmFkZHJlc3NCb29rW3RoaXMudG9dLnJlY2VpdmUoYWN0aW9uKVxuICB9XG59XG5cbi8vIFRodW5rIGluc3RhbmNlcyBhcmUgZW50aXRpZXMgaW4gYSB2aXJ0dWFsIGRvbSB0cmVlIHRoYXQgcmVwcmVzZW50XG4vLyBsYXppbHkgY29tcHV0ZSBzdWItdHJlZXMgd2l0aCBidWlsdC1pbiBjYWNoaW5nIHRoYXQgYXZvaWQgcmUtY29tcHV0aW5nXG4vLyBzdWItdHJlZSB3aGVuIHNhbWUgZGF0YSBpcyBiZWluZyByZW5kZXJlZC5cbmNsYXNzIFRodW5rIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgc3RhdGljIGZvcih2aWV3LCBrZXkpIHtcbiAgICBjbGFzcyBSZWFjdENvbXBvbmVudCBleHRlbmRzIFRodW5rIHtcbiAgICAgIGNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHByb3BzLCBjb250ZXh0KVxuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgICB9XG4gICAgfVxuICAgIFJlYWN0Q29tcG9uZW50LmRpc3BsYXlOYW1lID0ga2V5LnNwbGl0KCdAJylbMF07XG4gICAgcmV0dXJuIFJlYWN0Q29tcG9uZW50XG4gIH1cbiAgY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpIHtcbiAgICBzdXBlcihwcm9wcywgY29udGV4dClcbiAgfVxuICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgY29uc3Qge2FyZ3N9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IGNvdW50ID0gYXJncy5sZW5ndGhcblxuICAgIGNvbnN0IGFkZHJlc3NCb29rID0gbmV3IEFycmF5KGNvdW50KVxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBBcnJheShjb3VudClcblxuICAgIGxldCBpbmRleCA9IDBcbiAgICB3aGlsZSAoaW5kZXggPCBjb3VudCkge1xuICAgICAgY29uc3QgYXJnID0gYXJnc1tpbmRleF1cbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBBZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3NCb29rW2luZGV4XSA9IGFyZ1xuICAgICAgICBwYXJhbXNbaW5kZXhdID0gbmV3IEFkZHJlc3MobmV3IEZvcndhcmRlcihhZGRyZXNzQm9vaywgaW5kZXgpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zW2luZGV4XSA9IGFyZ1xuICAgICAgfVxuICAgICAgaW5kZXggPSBpbmRleCArIDFcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHthcmdzOiBwYXJhbXMsIGFkZHJlc3NCb29rfSlcbiAgfVxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHthcmdzOiBhZnRlcn0pIHtcbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgY29uc29sZS50aW1lKGAke3RoaXMucHJvcHMuS2V5fS5jb21wdXRlYClcbiAgICB9XG5cbiAgICBjb25zdCB7YXJncywgYWRkcmVzc0Jvb2t9ID0gdGhpcy5zdGF0ZVxuXG4gICAgY29uc3QgY291bnQgPSBhZnRlci5sZW5ndGhcbiAgICBsZXQgaW5kZXggPSAwXG4gICAgbGV0IGlzVXBkYXRlZCA9IGZhbHNlXG5cbiAgICBpZiAoYXJncy5sZW5ndGggIT09IGNvdW50KSB7XG4gICAgICBpc1VwZGF0ZWQgPSB0cnVlXG4gICAgICBhcmdzLmxlbmd0aCA9IGNvdW50XG4gICAgICBhZGRyZXNzQm9vay5sZW5ndGggPSBjb3VudFxuICAgIH1cblxuICAgIHdoaWxlIChpbmRleCA8IGNvdW50KSB7XG4gICAgICBjb25zdCBuZXh0ID0gYWZ0ZXJbaW5kZXhdXG4gICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XVxuXG4gICAgICBpZiAobmV4dCA9PT0gYXJnKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIH0gZWxzZSBpZiAobmV4dCBpbnN0YW5jZW9mIEFkZHJlc3MgJiYgYXJnIGluc3RhbmNlb2YgQWRkcmVzcykge1xuICAgICAgICAvLyBVcGRhdGUgYWRycmVzcyBib29rIHdpdGggYSBuZXcgYWRkcmVzcy5cbiAgICAgICAgYWRkcmVzc0Jvb2tbaW5kZXhdID0gbmV4dFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNVcGRhdGVkID0gdHJ1ZVxuXG4gICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgQWRkcmVzcykge1xuICAgICAgICAgIGFkZHJlc3NCb29rW2luZGV4XSA9IG5leHRcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IG5ldyBBZGRyZXNzKHRoaXMsIFtyZWRpcmVjdChpbmRleCldKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gbmV4dFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbmRleCA9IGluZGV4ICsgMVxuICAgIH1cblxuICAgIGlmIChpc1VwZGF0ZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2FyZ3MsIGFkZHJlc3NCb29rfSlcbiAgICB9XG5cbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgY29uc29sZS50aW1lRW5kKGAke3RoaXMucHJvcHMuS2V5fS5jb21wdXRlYClcbiAgICB9XG4gIH1cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKF8sIHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlICE9PSB0aGlzLnN0YXRlXG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmIChwcm9maWxlKSB7XG4gICAgICBjb25zb2xlLnRpbWUoYCR7dGhpcy5wcm9wcy5LZXl9LnJlbmRlcmApXG4gICAgfVxuXG4gICAgLy8gU3RvcmUgY3VycmVudGx5IG9wZXJhdGluZyB2aWV3IHRvIGVuYWJsZSBjYWNoZWluZyBieVxuICAgIC8vIHRoZSB2aWV3LlxuICAgIFRodW5rLmNvbnRleHQgPSB0aGlzLnZpZXdcblxuICAgIGNvbnN0IHthcmdzfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZpZXcoLi4uYXJncylcblxuXG4gICAgVGh1bmsuY29udGV4dCA9IG51bGxcblxuICAgIGlmIChwcm9maWxlKSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQoYCR7dGhpcy5wcm9wcy5LZXl9LnJlbmRlcmApXG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuY29uc3QgY29udGV4dHVhbENhY2hlID0gbmV3IFdlYWtNYXAoKVxuY29uc3QgY29udGV4dGxlc3NDYWNoZSA9IG5ldyBXZWFrTWFwKClcblxuZXhwb3J0IGNvbnN0IGNhY2hlID0gKGYsIC4uLmFyZ3MpID0+IHtcbiAgbGV0IGNhY2hlID0gbnVsbFxuICBsZXQgY2hhbmdlZCA9IGZhbHNlXG4gIGNvbnN0IGNvbnRleHQgPSBUaHVuay5jb250ZXh0XG5cblxuICBpZiAoY29udGV4dCkge1xuICAgIGNhY2hlID0gY29udGV4dHVhbENhY2hlLmdldChmKVxuICAgIGlmICghY2FjaGUpIHtcbiAgICAgIGNvbnRleHR1YWxDYWNoZS5zZXQoZiwgY2FjaGUgPSBuZXcgV2Vha01hcCgpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYWNoZSA9IGNvbnRleHRsZXNzQ2FjaGVcbiAgfVxuXG4gIGxldCBtZW1vcnkgPSBjYWNoZS5nZXQoZilcbiAgaWYgKG1lbW9yeSkge1xuICAgIGNvbnN0IHtpbnB1dH0gPSBtZW1vcnlcblxuICAgIGNvbnN0IGNvdW50ID0gaW5wdXQubGVuZ3RoXG4gICAgbGV0IGluZGV4ID0gMFxuICAgIGxldCBjaGFuZ2VkID0gYXJncy5sZW5ndGggIT09IGNvdW50XG4gICAgd2hpbGUgKCFjaGFuZ2VkICYmIGluZGV4IDwgY291bnQgJiYgIWNoYW5nZWQpIHtcbiAgICAgIGNvbnN0IHBhc3QgPSBpbnB1dFtpbmRleF1cbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBhcmdzW2luZGV4XVxuXG4gICAgICBjaGFuZ2VkID0gY3VycmVudCAhPT0gcGFzdFxuICAgICAgaW5kZXggPSBpbmRleCArIDFcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgbWVtb3J5Lm91dHB1dCA9IGYoLi4uYXJncylcbiAgICAgIG1lbW9yeS5pbnB1dCA9IGFyZ3NcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWVtb3J5ID0ge291dHB1dDogZiguLi5hcmdzKSwgaW5wdXQ6IGFyZ3N9XG4gICAgY2FjaGUuc2V0KGYsIG1lbW9yeSlcbiAgfVxuXG4gIHJldHVybiBtZW1vcnkub3V0cHV0XG59XG5cbi8vIHJlbmRlciBmdW5jdGlvbiBwcm92aWRlcyBzaG9ydGN1dCBmb3IgcmVuZGVyaW5nIGEgbW9kZWwgd2l0aFxuLy8gZGVmYXVsdCB2aWV3IGZ1bmN0aW9uIChhbHRob3VnaCBjdXN0b20gdmlldyBmdW5jdGlvbiBjYW4gYmVcbi8vIHBhc3NlZCBhcyBzZWNvbmQgb3B0aW9uYWwgYXJndW1lbnQpLCBidXQgdW5saWtlIGNhbGxpbmcgdmlld1xuLy8gZGlyZWN0bHkgcmVzdWx0IGlzIGEgdGh1bmssIHRoZXJlIGZvciBpdCdzIGRlZmVycyBhY3R1YWwgY29tcHV0YXRpb25cbi8vIGFuZCBtYWtlcyB1c2Ugb2YgY2FjaGluZyB0byBhdm9pZCBjb21wdXRhdGlvbiB3aGVuIHBvc3NpYmxlLlxuZXhwb3J0IGNvbnN0IHJlbmRlciA9IChrZXksIHZpZXcsIC4uLmFyZ3MpID0+IHtcbiAgY29uc3QgY29tcG9uZW50ID0gdmlldy5yZWFjdENvbXBvbmVudCB8fFxuICAgICAgICAgICAgICAgICAgICAodmlldy5yZWFjdENvbXBvbmVudCA9IFRodW5rLmZvcih2aWV3LCBrZXkpKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCB7a2V5LCBLZXk6IGtleSwgYXJnc30pO1xufVxuXG5sZXQgR1VJRCA9IDBcblxuY29uc3QgUGFyYW1ldGVyaXplZFJlY2VpdmVyID0gKGFkZHJlc3MsIHJlYWQsIHByZWZpeCkgPT5cbiAgZXZlbnQgPT4gYWRkcmVzcy5yZWNlaXZlKHJlYWQoLi4ucHJlZml4LCBldmVudCkpO1xuXG5jb25zdCBSZWNlaXZlciA9IChhZGRyZXNzLCByZWFkKSA9PlxuICBldmVudCA9PiBhZGRyZXNzLnJlY2VpdmUocmVhZChldmVudCkpO1xuXG5leHBvcnQgY2xhc3MgQWRkcmVzcyB7XG4gIGNvbnN0cnVjdG9yKG1haWxib3gsIGZvcndhcmRlcnMpIHtcbiAgICB0aGlzLmlkID0gKytHVUlEXG4gICAgdGhpcy5tYWlsYm94ID0gbWFpbGJveFxuICAgIHRoaXMuZm9yd2FyZGVycyA9IGZvcndhcmRlcnNcbiAgfVxuICBmb3J3YXJkKGFub3RhdGUpIHtcbiAgICBjb25zdCBjYWNoZSA9IGFub3RhdGVbQWRkcmVzcy5jYWNoZV0gfHxcbiAgICAgICAgICAgICAgICAgIChhbm90YXRlW0FkZHJlc3MuY2FjaGVdID0ge30pXG5cbiAgICBpZiAoIWNhY2hlW3RoaXMuaWRdKSB7XG4gICAgICBjb25zdCBmb3J3YXJkZXJzID0gdGhpcy5mb3J3YXJkZXJzID8gW2Fub3RhdGVdLmNvbmNhdCh0aGlzLmZvcndhcmRlcnMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICBbYW5vdGF0ZV1cbiAgICAgIGNhY2hlW3RoaXMuaWRdID0gbmV3IEFkZHJlc3ModGhpcy5tYWlsYm94LCBmb3J3YXJkZXJzKVxuICAgIH1cblxuICAgIHJldHVybiBjYWNoZVt0aGlzLmlkXVxuICB9XG4gIHJlY2VpdmUoYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuaXNCbG9ja2VkICYmIGFjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgKHRoaXMucXVldWUgfHwgKHRoaXMucXVldWUgPSBbXSkpLnB1c2goYWN0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7Zm9yd2FyZGVyc30gPSB0aGlzXG4gICAgICB0aGlzLmlzQmxvY2tlZCA9IHRydWVcbiAgICAgIGxldCB0aWNrZXQgPSAtMVxuXG4gICAgICAvLyBEZWZpbmUgYSBgZGVsaXZlcmVkYCBmbGFnIHRoYXQgaXMgdXBkYXRlZCBhdCB0aGUgYmVnaW5pbmcgb2YgYWN0aW9uXG4gICAgICAvLyBkZWxpdmVyeSBhbmQgYXQgdGhlIGVuZCBvZiBpdC4gVGhpcyBpcyBzbyB0aGF0IGluIGZpbmFsbHkgd2UgY2FuXG4gICAgICAvLyBmaWd1cmUgb3V0IGlmIGV4Y2VwdGlvbiB3YXMgdGhyb3cgb3Igbm90LlxuICAgICAgbGV0IGRlbGl2ZXJlZCA9IGZhbHNlXG5cbiAgICAgIHdoaWxlICh0aGlzLmlzQmxvY2tlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRlbGl2ZXJlZCA9IGZhbHNlXG5cbiAgICAgICAgICBpZiAoYWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZm9yd2FyZGVycykge1xuICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IGZvcndhcmRlcnMubGVuZ3RoXG4gICAgICAgICAgICAgIGxldCBpbmRleCA9IDBcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgY291bnQpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBmb3J3YXJkZXJzW2luZGV4XShhY3Rpb24pXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1haWxib3gucmVjZWl2ZShhY3Rpb24pXG5cbiAgICAgICAgICAgIGRlbGl2ZXJlZCA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGlja2V0ID0gdGlja2V0ICsgMVxuICAgICAgICAgIHRoaXMuaXNCbG9ja2VkID0gdGhpcy5xdWV1ZSAmJiB0aGlzLnF1ZXVlLmxlbmd0aCA+IHRpY2tldFxuICAgICAgICAgIGFjdGlvbiA9IHRoaXMuaXNCbG9ja2VkICYmIHRoaXMucXVldWVbdGlja2V0XVxuXG4gICAgICAgICAgLy8gSWYgZmFpbGVkIHRvIGRlbGl2ZXIgKGV4Y2VwdGlvbiB3YXMgdGhyb3duKSBhbmQgYWRkcmVzcyBpcyBzdGlsbFxuICAgICAgICAgIC8vIGJsb2NrZWQgdGhhdCBtZWFucyB0aGVyZSBhcmUgc3RpbGwgcGVuZGluZyBhY3Rpb25zIHRvIHByb2Nlc3MuIEluXG4gICAgICAgICAgLy8gdGhhdCBjYXNlIHdlIHVuYmxvY2sgYW4gYWRkcmVzcyByZW1vdmUgZGVsaXZlcmVkIGFjdGlvbnMgZnJvbSBhXG4gICAgICAgICAgLy8gcXVldWUgYW5kIHJlLWVudGVyIHJlY2VpdmUgbG9vcC4gVGhpcyB3YXkgcmVjZWl2ZSBkcmFpbnMgYWN0aW9uXG4gICAgICAgICAgLy8gYWN0aW9uIGxvb3AgcmVnYXJkbGVzcyBvZiBleGNlcHRpb25zIHRoYXQgbWF5IG9jY3VyLlxuICAgICAgICAgIGlmICghZGVsaXZlcmVkICYmIHRoaXMuaXNCbG9ja2VkKSB7XG4gICAgICAgICAgICB0aGlzLmlzQmxvY2tlZCA9IGZhbHNlXG4gICAgICAgICAgICB0aGlzLnF1ZXVlICYmIHRoaXMucXVldWUuc3BsaWNlKDAsIHRpY2tldCArIDEpXG4gICAgICAgICAgICB0aGlzLnJlY2VpdmUoYWN0aW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnF1ZXVlICYmIHRoaXMucXVldWUuc3BsaWNlKDApXG4gICAgfVxuICB9XG4gIHNlbmQoYWN0aW9uKSB7XG4gICAgcmV0dXJuIF8gPT4gdGhpcy5yZWNlaXZlKGFjdGlvbilcbiAgfVxuICBwYXNzKHJlYWQsIC4uLnByZWZpeCkge1xuICAgIGlmICh0eXBlb2YocmVhZCkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTm9uIGZ1bmN0aW9uIHdhcyBwYXNzZWQgdG8gYWRkcmVzcy5wYXNzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZpeC5sZW5ndGggPyBQYXJhbWV0ZXJpemVkUmVjZWl2ZXIodGhpcywgcmVhZCwgcHJlZml4KSA6XG4gICAgICAgICAgIChyZWFkW2ByZWZsZXgvYWRkcmVzcy0ke3RoaXMuaWR9YF0gfHxcbiAgICAgICAgICAgIChyZWFkW2ByZWZsZXgvYWRkcmVzcy0ke3RoaXMuaWR9YF0gPSBSZWNlaXZlcih0aGlzLCByZWFkKSkpO1xuICB9XG59XG5BZGRyZXNzLmNhY2hlID0gU3ltYm9sLmZvcigncmVmbGV4L2FkZHJlc3MtYm9vaycpXG5cbi8vIFByb2dyYW0gaXMgYSByb290IGVudGl0eSBvZiB0aGUgdmlydHVhbCBkb20gdHJlZSB0aGF0IGlzIHJlc3BvbnNpYmxlXG4vLyBmb3IgY29tcHV0aW5nIGEgdmlydHVhbCBkb20gdHJlZSBmb3IgdGhlIGBzdGF0ZWAgdmlhIGdpdmVuIGB2aWV3YCBmdW5jdGlvblxuLy8gYW5kIHJlYWN0aW5nIHRvIGRpc3BhdGNoZWQgYWN0aW9ucyB2aWEgZ2l2ZW4gYHVwZGF0ZWAgYnkgdXBkYXRpbmcgYSBzdGF0ZVxuLy8gYW5kIHJlc3RhcnRpbmcgYSB0aGUgc2FtZSBjeWNsZSBhZ2Fpbi5cbmV4cG9ydCBjbGFzcyBBcHBsaWNhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHthZGRyZXNzLCB0YXJnZXQsIHN0YXRlLCB1cGRhdGUsIHZpZXd9KSB7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXRcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy51cGRhdGUgPSB1cGRhdGVcbiAgICB0aGlzLnN0YXRlID0gc3RhdGVcbiAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gIH1cbiAgcmVjZWl2ZShhY3Rpb24pIHtcbiAgICB0aGlzLmFjdGlvbiA9IGFjdGlvblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy51cGRhdGUodGhpcy5zdGF0ZSwgdGhpcy5hY3Rpb24pXG4gICAgaWYgKHN0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGVcbiAgICAgIHRoaXMuc2NoZWR1bGUoKVxuICAgIH1cbiAgfVxuICBzY2hlZHVsZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNTY2hlZHVsZWQpIHtcbiAgICAgIHRoaXMuaXNTY2hlZHVsZWQgPSB0cnVlXG4gICAgICB0aGlzLnZlcnNpb24gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIpXG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgY29uc29sZS50aW1lKCdSZWFjdC5yZW5kZXInKVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byBtYXJrIGBpc1NjaGVkdWxlZGAgYXMgYGZhbHNlYCBiZWZvcmUgZG9pbmcgYWN0dWFsXG4gICAgLy8gcmVuZGVyaW5nIHNpbmNlIHN0YXRlIGNoYW5nZXMgaW4gZWZmZWN0IG9mIHJlZmxlY3RpbmcgY3VycmVudCBzdGF0ZVxuICAgIC8vIHdvbid0IGJlIGhhbmRsZWQgYnkgdGhpcyByZW5kZXIgY3ljbGUuIEZvciBleGFtcGxlIHJlbmRlcmluZyBhIHN0YXRlXG4gICAgLy8gd2l0aCB1cGRhdGVkIGZvY3VzIHdpbGwgY2F1c2UgYGJsdXJgICYgYGZvY3VzYCBldmVudHMgdG8gYmUgZGlzcGF0Y2hlZFxuICAgIC8vIHRoYXQgaGFwcGVuIHN5bmNocm9ub3VzbHksIGFuZCB0aGVyZSBmb3IgYW5vdGhlciByZW5kZXIgY3ljbGUgbWF5IGJlXG4gICAgLy8gc2NoZWR1bGVkIGZvciB3aGljaCBgaXNTY2hlZHVsZWRgIG11c3QgYmUgYGZhbHNlYC4gQXR0ZW1wdCB0byByZW5kZXJcbiAgICAvLyB0aGlzIHN0YXRlIG1heSBhbHNvIGNhdXNlIGEgcnVudGltZSBleGNlcHRpb24gYnV0IGV2ZW4gdGhlbiB3ZSB3b3VsZFxuICAgIC8vIHJhdGhlciBhdHRlbXB0IHRvIHJlbmRlciB1cGRhdGVkIHN0YXRlcyB0aGF0IGVuZCB1cCBiZWluZyBibG9ja2VkXG4gICAgLy8gZm9yZXZlci5cbiAgICB0aGlzLmlzU2NoZWR1bGVkID0gZmFsc2VcbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgY29uc29sZS50aW1lKCdBcHBsaWNhdGlvbi5yZW5kZXInKVxuICAgIH1cblxuICAgIHRoaXMudHJlZSA9IHRoaXMudmlldyh0aGlzLnN0YXRlLCB0aGlzLmFkZHJlc3MpXG5cbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgY29uc29sZS50aW1lRW5kKCdBcHBsaWNhdGlvbi5yZW5kZXInKVxuICAgIH1cblxuICAgIGlmIChwcm9maWxlKSB7XG4gICAgICBjb25zb2xlLnRpbWUoJ1JlYWN0LnJlY29uY2lsZScpXG4gICAgfVxuXG4gICAgUmVhY3QucmVuZGVyKHRoaXMudHJlZSwgdGhpcy50YXJnZXQpXG5cbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgY29uc29sZS50aW1lRW5kKCdSZWFjdC5yZWNvbmNpbGUnKVxuICAgIH1cblxuICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY29uc3QgdGltZSA9IGVuZCAtIHN0YXJ0XG5cbiAgICBpZiAodGltZSA+IDE2KSB7XG4gICAgICBjb25zb2xlLndhcm4oYFJlbmRlciB0b29rICR7dGltZX1tcyAmIHdpbGwgY2F1c2UgZnJhbWUgZHJvcGApXG4gICAgfVxuXG4gICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgIGNvbnNvbGUudGltZUVuZCgnUmVhY3QucmVuZGVyJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG4vLyBGdW5jdGlvbiB0aGF0IHRha2VzIGB0YXJnZXRgIGVsZW1lbnQgdG8gY29udGluaXVzbHkgcmVuZGVyIGdpdmVuIGBtb2RlbGBcbi8vIGludG8uIG1vZGVsJ3MgZGVmYXVsdCBgdXBkYXRlYCBmdW5jdGlvbiBpcyB1c2VkIHRvIHVwZGF0ZSBtb2R1bGUgaW4gcmVzcG9uc2Vcbi8vIHRvIGRpc3BhdGNoZWQgYWN0aW9ucyBhbmQgbW9kZWwncyBkZWZhdWx0IGB2aWV3YCBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbXB1dGVcbi8vIGRvbSB0cmVlIHJlcHJlc2FudGF0aW9uIG9mIHRoZSBtb2RlbC4gT3B0aW9uYWxseSBjdXN0b20gYHVwZGF0ZWAgYW5kIGB2aWV3YFxuLy8gZnVuY3Rpb25zIGNvdWxkIGJlIHBhc3NlZCB0byBjdXN0b21pemUgcmVuZGVyIGxvb3AuXG5leHBvcnQgbGV0IG1haW4gPSAodGFyZ2V0LCBtb2RlbCwgdXBkYXRlPW1vZGVsLmNvbnN0cnVjdG9yLnVwZGF0ZSwgdmlldz1tb2RlbC5jb25zdHJ1Y3Rvci52aWV3KSA9PiB7XG4gIGNvbnN0IGFwcGxpY2F0aW9uID0gbmV3IEFwcGxpY2F0aW9uKHtcbiAgICBzdGF0ZTogbW9kZWwsXG4gICAgdGFyZ2V0LCB1cGRhdGUsIHZpZXdcbiAgfSlcbiAgYXBwbGljYXRpb24uYWRkcmVzcyA9IG5ldyBBZGRyZXNzKGFwcGxpY2F0aW9uKTtcblxuICBhcHBsaWNhdGlvbi5zY2hlZHVsZSgpXG4gIHJldHVybiBhcHBsaWNhdGlvblxufVxuXG5sZXQgcHJvZmlsZSA9IG51bGxcbmV4cG9ydCBjb25zdCB0aW1lID0gKG5hbWU9JycpID0+XG4gIHByb2ZpbGUgPSBgJHtuYW1lfSBgXG5leHBvcnQgY29uc3QgdGltZUVuZCA9ICgpID0+XG4gIHByb2ZpbGUgPSBudWxsXG4iXX0=